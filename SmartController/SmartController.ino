#include "Tlc5940.h"
#include <EEPROM.h>
#include <SoftwareSerial.h>
String dataIn = "";
boolean flag, parse_flag;
SoftwareSerial btSerial(6, 5); // RX, TX

int interceptBright = 0;
int interceptorArray [16][1] {};
int temp_Array[17];
int data_Array[17];     // рабочий массив с настройками
int default_Array[17] = {980,10,80,90,7,50,2000,1,16,200,1900,50,3000,10000,50,10,9};   // дефолтные настройки
// int user_Array[17] лежит в EEPROM по адресу 0.
//int command;
// Изменяемые настройки:
//======================================================================================================================
// настройки фоторезистора
//unsigned int night = 980;             //[0] референсное значение фоторезистора, выше которого считается ночь;
//int histeresis = 10;                  //[1] задержка переключения ночь-день
//настройки ультразвуковых датчиков
//int distanceTopOperate = 80;          //[2] расстояние, при котором сработает верхний датчик, (см)
//int distanceBottomOperate = 90;       //[3] расстояние, при котором сработает нижний датчик, (см)
//int distanceSwitch = 7;               //[4] расстояние, меньше которого сработает выключатель (включение/выключение всей лестницы), (см)
//int ZadergkaSensora = 50;             //[5] задержка между выстрелами сенсоров, (миллисекунды)
//int sensorPollingDelay = 2000;        //[6] интервал задержки срабатывания датчиков, чтобы одно пересечение не считалось за несколько, (миллисекунды)
//byte operateNumber = 1;               //[7] количество срабатываний датчика для запуска функций (защита от случайных срабатываний и эл.магн. помех)
// настройки свечения ступеней
//byte numberOfSteps = 16;              //[8] количество ступеней лестницы, (шт.)
//int emergencyLighting = 200;          //[9] яркость первой и последней ступенек в ночном режиме, (дежурное освещение)
//int maxBrightness = 1900;             //[10] максимальная яркость свечения, (min 0 - 4095 max)
//int delaySwitchingNextStep = 50;      //[11] задержка перед включением/выключением следующей ступени, (миллисекунды)
//int timeGlowStep = 3000; 			        //[12] задержка свечения каждой ступени перед выключением, (миллисекунды)
//int timeAllSteps = 10000;             //[13] задержка свечения всей лестницы, (миллисекунды)
//int stepPWM = 50;                     //[14] шаг увеличения яркости ШИМ, (min 0 - 4095 max)
//int delayPWM = 10;                    //[15] задержка между шагами ШИМ (плавное включение), (миллисекунды) нельзя устанавливать 0
//byte landing = 9;                     //[16] площадка разворота лестницы, (№ ступени)


//======================================================================================================================
// --------- Инициализация ---------------------------------------------------------------------------------------------
void setup() {
  if (EEPROM.read(1000) != 123){                    // если по адресу 1000 нет ключа со значением 123 (первый запуск)
    EEPROM.write(1000, 123);                        // запишем ключ
    EEPROM.put(0,default_Array);                    // запишем в память массив с дефолтными настройками, начиная с адреса 0
  }

  Tlc.init(0);                                      // гасим все ступени
  btSerial.begin(57600);                            // открываем последовательный порт на скорости 57600
  Serial.begin(9600);
  EEPROM.get(0,data_Array);                      // загружаем из памяти в рабочий массив настройки пользователя
  //int interceptorArray [data_Array[8]][1] {};
}
//----------------------------------------------------------------------------------------------------------------------

void loop() {

/*  
  if(Serial.available()){
    for (int i=0; i < sizeof(data_Array)/sizeof(int); i++){
          Serial.println(data_Array[i]);
          Serial.println(sizeof(data_Array)/sizeof(int));
    }
  }
*/
  //--------- Проверка наличия входных данных -------------------------------------------------------------
  while (btSerial.available()>0){                // если данные поступили
      dataIn += (char)btSerial.read();                // набиваем переменную данными
      flag = true;                                  // устанавливаем флаг, что данные получены
      delay(2);                                     // маленькая задержка (без нее коряво работает)
  }
  //-------------------------------------------------------------------------------------------------------
  //--------- Блок разбора полученных данных --------------------------------------------------------------
  if (flag) {                                       // проверяем, если флаг установлен
    flag = false;                                   // сбрасываем флаг
    String command = dataIn.substring(1);           // переносим данные в новую переменную без первого символа 
    switch ((uint8_t)dataIn[0]){                             // ищем совпадение по первому символу данных (в полной строке)
    //------- ???????? ------------------------------------------------------------------------------------
      case 0x24:                                     // если $
        btSerial.println(command);                  //

        break;
    //-----------------------------------------------------------------------------------------------------
    //------- Блок разбора и сохранения настроек ----------------------------------------------------------    
      case 0x23:                                     // если #
        if (command.endsWith("#")) {                              // если строка заканчивается #
          command = command.substring(0, command.length() - 1);       // обрезаем последний символ строки
          //    Serial.println("command: " + command);            
          getSettings(command);                                       // парсим строку
        } else outData(1, (uint8_t)command.toInt(), 0);                               // иначе - сообщение пользователю
        btSerial.println();
        break;
    //-----------------------------------------------------------------------------------------------------

    //------- Временный блок вывода значения из EEPROM по запросу -----------------------------------------
      case 0x21:                                     // если !
        // Serial.println(command);            
        qwerty(command);                                // 
        break;
    //-----------------------------------------------------------------------------------------------------

    //------- Временный блок для отладки (выводит все данные из рабочего массива и из EEPROM) -------------  
      case 0x3F:                                     // если ?
            for (int i=0; i < (int)(sizeof(data_Array)/sizeof(int)); i++){
              btSerial.print(data_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
/*        EEPROM.get(0,temp_Array);
            for (int i=0; i < (int)(sizeof(data_Array)/sizeof(int)); i++){
              btSerial.print(temp_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
*/        break;
    //-----------------------------------------------------------------------------------------------------

    //------- Временный блок для отладки (обнуление ключа EEPROM) ------//
      case 0x2A:                                       // если *
        EEPROM.put(1000,255);
        break;
    //------------------------------------------------------------------//
      
      case 0x40:                                   // если @
        parser (dataIn[1]);                         // парсим второй символ принятых данных
        break;
      default:                                    // если совпадений нет
        btSerial.println("Неверная команда!");        // сообщение пользователю
        break;
    }
    dataIn = "";                                    // обнуляем входные данные
    command = "";
    
  }
}

//------------ Временный блок для отладки (удалить) -------------------------------------
void qwerty (String qwerty){            // принимаем значение
          int t;
          int ini = qwerty.toInt();           // преобразовываем его в адрес
          EEPROM.get(ini*2, t);                 // вытаскиваем данные из EEPROM по данному адресу из массива
          btSerial.println(t);                  // печатаем значение
}
//---------------------------------------------------------------------------------------

//------------ Блок парсера пользовательских настроек с записью в память и рабочий массив ---------------------------------------------------
void getSettings (String data) {                      // получаем блок данных (строка с данными и разделителями)
  String temp;
  int addr, val;
  do {                                                        // выполнить
    if (data.indexOf(";", 0) != -1) {                             // если блок содержит хоть один разделитель ';' 
      temp = data.substring(0, data.indexOf(";", 0));                 // во временную переменную пишем подстроку до ближайшего разделителя ';'
      data.remove(0, data.indexOf(";", 0)+1);                         // обрезаем блок от начала вместе с разделителем ';'      
      if (temp[1] == ':' || temp[2] == ':') {                         // если 2-й или 3-й символ это разделитель ':'
        addr = temp.substring(0,temp.indexOf(":", 0)).toInt();          // записываем в переменную адрес (значение до разделителя ':')
        val = temp.substring(temp.indexOf(":", 0)+1).toInt();           // записываем в переменную само значение (после разделителя ':')
        data_Array[addr] = val;                                         // пишем значение по указанному адресу в рабочий массив
      //  EEPROM.put((addr)*2,val);             временно отключен - переписать запись по требованию приложения     // пишем значение по указанному адресу в EEPROM
        onlineBright(val);                                              // вызов функции немедленного изменения яркости
      }
    } else {                                                      // иначе, сообщение оператору и выход из цикла
      outData(1, (uint8_t)data.toInt(), 0); 
      break;
    }
  } while (data != "");                                       // повторяем цикл, пока не закончится блок с данными
  temp = "";                                                  // обнуляем переменные
  val = 0; 
  addr = 0;
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//------------ Блок вывода сообщений пользователю -------------------------------------------------------------------------------------------
void outData (int value, uint8_t dataOut, byte additional){              // принимаем блок данных (вид сообщения, данные, дополнительные данные)
  switch (value) {                                        // ищем совпадения по значению
    case 1:                                                   // если 1, то 
      btSerial.println("Неверная команда: " + dataOut);              // вывод сообщения со значением
      break;
    case 2:                                                   // если 2, то 
      btSerial.println("Неизвестная команда: " + dataOut);              // вывод сообщения со значением
      break;
    case 3:
      btSerial.print(dataOut, HEX);
      btSerial.print(",");
      btSerial.println(additional, HEX);
  }
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//------------ Блок парсера сценариев -------------------------------------------------------------------------------------------------------
void parser (char data){                                     // получаем данные
  
  switch ((uint8_t)data) {                                               // ищем совпадение по символу
    case 0x55:
      up(0, data_Array[10], data_Array[14], 1);                   // включаем ступени последовательно вверх
      break;
    case 0x75:
      up(data_Array[10], 0, data_Array[14], 0);                   // выключаем ступени последовательно вверх
      break;
    case 0x44:
      down(0, data_Array[10], data_Array[14], 1);                 // включаем ступени последовательно вниз
      break;
    case 0x64:
      down(data_Array[10], 0, data_Array[14], 0);                 // выключаем ступени последовательно вниз
      break;
    case 0x41:
      all(data_Array[10], 1);                                     // включаем все ступени разом
      break;
    case 0x61:
      all(0, 0);                                                  // выключаем все ступени разом
      break;
    case 0x46:
      different(0, data_Array[10], data_Array[14], 1);            // включаем ступени от середины в разные стороны
      break;
    case 0x66:
      different(data_Array[10], 0, data_Array[14], 0);            // выключаем ступени от середины в разные стороны
      break;
    case 0x54:
      towards(0, data_Array[10], data_Array[14], 1);              // включаем ступени навстречу с разных сторон
      break;
    case 0x74:
      towards(data_Array[10], 0, data_Array[14], 0);              // выключаем ступени навстречу с разных сторон
      break;
    case 0x53:
      sos(4095, 0);                                               // режим SOS, (максимальная яркость, зациклить -1 или один раз -0)
      break;
    case 0x4C:
      luminescent(data_Array[10]);                                // включаем все ступени с эффектом люминесцентной лампы
      break;
    case 0x43:                      // если С    временный блок - удалить!
      Tlc.clear();
      Tlc.update();
      break;
    default:                                                   // если совпадений нет
      outData (2, (uint8_t)data, 0);                                  // сообщение оператору
      break;
    }
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//-------------Изменение яркости "на лету"---------------------------------------------------------------------------------------------------
void onlineBright (int val) {
    for (int i = 0; i <= data_Array[8]; i++) {
      Tlc.set(i, val);
  }
  Tlc.update();
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней снизу вверх ------------------------------------------------------------------------------------
void up (int initVal, int target, int stepPWM, bool state) {          // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
    outData(3, state ? 0x55 : 0x75, state);                             // ответ пользователю, что команда выполняется
    for (int step = 0; step < data_Array[8]; step ++) {                 // начиная с 0 увеличиваем ступень на 1
      if (btSerial.available()>0) {                                       // проверяем, если есть ли новые данные на входе, то
          Tlc.clear();                                                      // тушим все ступени
          Tlc.update();                                                     // применяем изменения
          break;                                                            // покидаем блок
        }
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if (Tlc.get(step) == target && state) break;                    // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
	      }
   }
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней сверху вниз -----------------------------------------------------------------------------------
void down (int initVal, int target, int stepPWM, bool state) {        // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
    outData(3, state ? 0x44 : 0x64, state);                             // ответ пользователю, что команда выполняется
    for (int step = data_Array[8]; step >= 0; step --) {                // начиная с последней уменьшаем ступень на 1
      if (btSerial.available()>0) {                                        // проверяем, если есть ли новые данные на входе, то
          Tlc.clear();                                                        // тушим все ступени
          Tlc.update();                                                       // применяем изменения
          break;                                                              // покидаем блок
        }
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM :u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if (Tlc.get(step) == target && state) break;                    // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
	      }
    } 
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение всех ступеней разом ------------------------------------------------------------------------------------
void all (int bright, bool state) {                                     // параметры (яркость, состояние 0-выключить, 1-включить)
  outData(3, state ? 0x41 : 0x61, state);                                   // ответ пользователю, что команда выполняется
  Tlc.setAll(bright);                                                       // всем ступеням назначаем указанную яркость
  for (int i = 0; i <= data_Array[8]; i++) {
    interceptorArray[i][1] = bright;
  }
  Tlc.update();                                                             // применяем изменения
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней от середины к краям ---------------------------------------------------------------------------
void different (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  int up, down;
  outData(3, state ? 0x46 : 0x66, state);                                   // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                            // вычисляем среднюю ступень

    for (up = center, center % 2 == 0 ? down = center - 1: down = center; up < data_Array[8]; up ++, down --) {   // отсчет ведем в зависимости от четности ступеней 
      if (btSerial.available()>0) {                                         // проверяем, если есть ли новые данные на входе, то
          all(0, 0);                                                        // тушим все ступени
          break;                                                            // покидаем блок
        }
        for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
          if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
          if ((Tlc.get(up) == target || Tlc.get(down) == target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
            Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей вверх
            Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей вниз
            Tlc.update();                                                  // применяем изменения
            delay(data_Array[15]);                                         // применяем установленную задержку
        } 
    } 
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней от краев навстречу друг другу ----------------------------------------------------------------- 
void towards (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  outData(3, state ? 0x54 : 0x74, state);                                  // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                           // вычисляем среднюю ступень

    for (int up = 0, down = data_Array[8] - 1; center % 2 == 0 ? up < center: up <= center; up ++, down --) {   // в зависимости от четности ступеней устанавливаем среднюю ступень
      if (btSerial.available()>0) {                                        // проверяем, если есть ли новые данные на входе, то
          all(0, 0);                                                       // тушим все ступени
          break;                                                           // покидаем блок
        }
        for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
          if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
          if ((Tlc.get(up) == target || Tlc.get(down) == target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
            Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей сверху
            Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей снизу
            Tlc.update();                                                  // применяем изменения
            delay(data_Array[15]);                                         // применяем установленную задержку
        }
    } 
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение режима SOS --------------------------------------------------------------------------------------------------------
void sos (int bright, bool state) {                                  // параметры (яркость, состояние 1-включить)
  outData(3, 0x53, state);                                              // ответ пользователю, что команда выполняется

  byte cycle = 0;                                                       // 
  byte on = 0;
  int pause = 200;                                                      // задаем значение паузы
        Tlc.setAll(0);                                                  // выключаем все ступени
        Tlc.update();
  delay (1000);                                                         // пауза перед включением

  while (cycle < 3) {                                                   // если прошло менее трех циклов, то
    if (btSerial.available()>0) {                                         // проверяем, если есть ли новые данные на входе, то
          all(0, 0);                                                      // тушим все ступени
          break;                                                          // покидаем блок
        }
    if (cycle == 2) {                                                     // если уже третий цикл
      delay (pause);                                                        // применяем паузу
      pause = 200;                                                          // меняем значение паузы
    }
    do {                                                                  // выполняем код ниже до условия
      delay (pause);                                                        // пауза
        Tlc.setAll(bright);                                                 // устанавливаем всем ступеням указанную яркость
        Tlc.update();                                                       // применяем изменения
      delay (pause);                                                        // пауза
        Tlc.setAll(0);                                                      // тушим все ступени
        Tlc.update();                                                       // применяем изменения
       on ++;                                                               // увеличиваем счетчик
    } while (on < 3);                                                     // условие - пока счетчик менее трех
    on = 0;                                                               // сбрасываем счетчик
    pause = 500;                                                          // меняем значение паузы
    cycle ++;                                                             // увеличиваем общий счетчик циклов
  }

}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение ступеней имитируя люминесцентную лампу ----------------------------------------------------------------------------
void luminescent (int bright) {                                      // параметры (яркость)

  byte f = 0;
  int pause = 1000;
  outData(3, 0x4C, 1);

  Tlc.setAll(0);
  Tlc.update();
  for (int first = 0, last = data_Array[8] - 1, b = 0; b <= bright ; b ++) {
    if (btSerial.available()>0) {
          all(0, 0);
          break;
        }
    Tlc.set(first, b);
    Tlc.set(last, b);
    Tlc.update();
    delayMicroseconds(500);
  } 

  Tlc.setAll(bright);
  Tlc.update();
  delay(700);
  
  do {
    if (btSerial.available()>0) {
          all(0, 0);
          break;
        }
    Tlc.setAll(bright/8);
    Tlc.update();

      delay(pause/2);

    for (int b = bright/8; b < bright; b ++) {
      Tlc.setAll(b);
      Tlc.update();
    }

    pause /= 4;
    f ++;
    delay(pause);
    Serial.println(pause);
  } while (f < 5);

}
//------------------------------------------------------------------------------------------------------------------------------------------
