#include "Tlc5940.h"                  // подключаем библиотеку драйвера
#include "Ultrasonic.h"               // подключаем библиотеку ультразвуковых датчиков
#include <EEPROM.h>
#include <SoftwareSerial.h>

#define T1 6                          // устанавливаем контакты для верхнего датчика
#define E1 5                          // устанавливаем контакты для верхнего датчика
#define T2 7                          // устанавливаем контакты для нижнего датчика
#define E2 8                          // устанавливаем контакты для нижнего датчика
#define FOTO A1                       // устанавливаем контакт для фоторезистора
Ultrasonic TopSensor(T1, E1);         // определяем нижний датчик
Ultrasonic BottomSensor(T2, E2);      // определяем верхний датчик

//boolean OperatorControl = 0;          // флаг перевода контроллера в режим удаленного управления оператором
//boolean Flags_Array[0] = 0;              // флаг перехода в режим ожидания (выключение работы лестницы, ожидание переключения в боевой режим по Bluetooth)
//boolean Flags_Array[1] = 0;
//boolean UpFlag, DownFlag, AllFlag, DifferentFlag, TowardsFlag, SOSFlag, LuminescentFlag;
boolean Flags_Array[11];              // массив флагов текущих состояний (порядок см. ниже)
//[0]-StandbyMode; [1]-DefaultSettings; [2]-night; [3]-cycle_flag; [4]-UpFlag; [5]-DownFlag; [6]-AllFlag; [7]-DifferentFlag; [8]-TowardsFlag; [9]-SOSFlag; [10]-LuminescentFlag;
boolean stop = 0;                     // флаг для остановки всех задач по входной команде 0х24 ($)
boolean dark = 0;                     // переключатель, если 0 - то темно, 1 - светло
//boolean Flags_Array[2] = 0;                    // переключатель, если 0 - то день, 1 - ночь
int darkness = 0;                    // накопительная переменная для проверки день - ночь

unsigned long currentTime = 1UL;
unsigned long startTime = 1UL;

  String dataCollect = "";
String dataIn = "";                   // переменная для входных данных
// String pause_data = "";               // переменная временного хранения данных во время проверки новых входящих данных
boolean data_flag = false;
SoftwareSerial btSerial(2, 4); // RX, TX

int interceptBright = 0;
int interceptorArray [16][1] {};
int default_Array[17] = {980,10,80,90,7,50,2000,1,16,200,1900,50,3000,10000,50,10,9};   // дефолтные настройки
int data_Array[sizeof(default_Array)];     // рабочий массив с настройками
int temp_Array[sizeof(default_Array)];     // временный массив для вывода данных из EEPROM при запросе
// int user_Array[17] лежит в EEPROM по адресу 0.

// Изменяемые настройки:
//==========================================================================================================================================
// настройки фоторезистора
//unsigned int dark = 980;              + //[0] референсное значение фоторезистора, выше которого считается ночь;
//int hysteresis = 10;                  + //[1] гистерезис переключения ночь-день
//настройки ультразвуковых датчиков
//int distanceTopOperate = 80;          + //[2] расстояние, при котором сработает верхний датчик, (см)
//int distanceBottomOperate = 90;       + //[3] расстояние, при котором сработает нижний датчик, (см)
//int distanceSwitch = 7;               + //[4] расстояние, меньше которого сработает выключатель (включение/выключение всей лестницы), (см)
//int ZadergkaSensora = 50;             + //[5] задержка между выстрелами сенсоров, (миллисекунды)                                                          ---------   установить интервал от 15 - и выше.
//int sensorPollingDelay = 2000;        //[6] интервал задержки срабатывания датчиков, чтобы одно пересечение не считалось за несколько, (миллисекунды)
//byte operateNumber = 1;               + //[7] количество срабатываний датчика для запуска функций (защита от случайных срабатываний и эл.магн. помех)      ---------     убрать - заменить
// настройки свечения ступеней
//byte numberOfSteps = 16;              + //[8] количество ступеней лестницы, (шт.)
//int emergencyLighting = 200;          + //[9] яркость первой и последней ступенек в ночном режиме, (дежурное освещение)
//int maxBrightness = 1900;             + //[10] максимальная яркость свечения, (min 0 - 4095 max)
//int delaySwitchingNextStep = 50;      //[11] задержка перед включением/выключением следующей ступени, (миллисекунды)
//int timeGlowStep = 3000; 			        //[12] задержка свечения каждой ступени перед выключением, (миллисекунды)
//int timeAllSteps = 10000;             //[13] задержка свечения всей лестницы, (миллисекунды)
//int stepPWM = 50;                     //[14] шаг увеличения яркости ШИМ, (min 0 - 4095 max)
//int delayPWM = 10;                    //[15] задержка между шагами ШИМ (плавное включение), (миллисекунды) нельзя устанавливать 0
//byte landing = 9;                     //[16] площадка разворота лестницы, (№ ступени)

//int top = 0;
//int bottom = 0;

//==========================================================================================================================================
// --------- Инициализация -----------------------------------------------------------------------------------------------------------------
void setup() {
  if (EEPROM.read(1000) != 123){                    // если по адресу 1000 нет ключа со значением 123 (первый запуск) // (при запросе учитывать, что ячейки  двухбайтовые - адрес 500)
    EEPROM.write(1000, 123);                        // запишем ключ
    EEPROM.put(0,default_Array);                    // запишем в память массив с дефолтными настройками, начиная с адреса 0
  }

  Tlc.init(0);                                      // гасим все ступени
  btSerial.begin(57600);                            // открываем последовательный порт на скорости 57600
  Serial.begin(9600);         // раскоментировать для отладки
  EEPROM.get(0,data_Array);                      // загружаем из памяти в рабочий массив настройки пользователя
  //int interceptorArray [data_Array[8]][1] {};
  startTime = millis();                             // сохраняем в переменную время старта в мс.

    for (int i=0; i <= (int)(sizeof(Flags_Array)); i++){
      Flags_Array[i] = 0;
    }

}
//==========================================================================================================================================

//----------- Основной цикл ----------------------------------------------------------------------------------------------------------------
void loop() {
 
  if (DataSerialAvailable()) {                         // проверяем, если флаг установлен
    data_flag = false;                                   // сбрасываем флаг
    DataParse();                                         // парсим входные данные
  } else {     
      if (!Flags_Array[0] && DayOrNight()) {                         // если Ночь и не режим ожидания
        emergencyLighting();                                        // включаем дежурную подсветку крайних ступеней
        stop = false;                                               // снимаем СТОП-флаг
        int top = sensorsCheck(TopSensor, data_Array[7]);           // опрашиваем верхний датчик
        int bottom = sensorsCheck(BottomSensor, data_Array[7]);     // опрашиваем нижний датчик

        if (bottom > data_Array[4] && bottom <= data_Array[3]) {
          up(0, data_Array[10], data_Array[14], 1);
        } else if (top > data_Array[4] && top <= data_Array[2]) {
          down(0, data_Array[10], data_Array[14], 1);
        }
      } else if (!Flags_Array[0]) {                                  // если не режим ожидания
            Tlc.setAll(0);                                                       // если День - тушим все ступени
            Tlc.update();                                                        // применяем изменения
      }
  }
}
//==========================================================================================================================================

//--------- Проверка наличия входных данных ------------------------------------------------------------------------------------------------
boolean DataSerialAvailable(){  
  while (btSerial.available()>0){                // если данные поступили
      dataIn += (char)btSerial.read();                // набиваем переменную данными
      data_flag = true;                                  // устанавливаем флаг, что данные получены
      delay(1);                                     // маленькая задержка (без нее коряво работает)
  }
  if(dataIn.endsWith("^")) {                        // если принятая строка заканчивается "^"
    delay(100);                                                     // необходимая задержка для синхронизации следующей посылки
    dataCollect += dataIn.substring(0, dataIn.length() - 1);        // сохраняем строку без последнего символа
    dataIn = "";                                                    // очищаем входную строку
    data_flag = false;                                              // снимаем флаг
    if (dataCollect.endsWith("|")) {                                // если строка заканчивается "|"
      dataCollect = dataCollect.substring(1, dataCollect.length() - 2);       // обрезаем первый и два последних символа строки
      getSettings(dataCollect);                                         // парсим строку
      dataCollect = "";                                             //
    } else {
//          outData(2, dataCollect, 0);               // иначе - сообщение пользователю "Неверные данные"
        }
  }




  if ((uint8_t)dataIn[0] == 0x24) {              // если первый символ '$' 
    stop = true;
    dataIn = "";                                    // очищаем входные данные
    data_flag = false;
  }
  return data_flag;
}
//==========================================================================================================================================

//--------- Блок разбора полученных данных -------------------------------------------------------------------------------------------------
void DataParse() {

    String command = dataIn.substring(1);           // переносим данные в новую переменную без первого символа 
    
    switch ((uint8_t)dataIn[0]){                             // ищем совпадение по первому символу данных (в полной строке)
    //::::::: Блок разбора и сохранения настроек ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      case 0x23:                                     // если #
        if (command.endsWith("#")) {                              // если строка заканчивается #
          command = command.substring(0, command.length() - 1);       // обрезаем последний символ строки            
          getSettings(command);                                       // парсим строку
        } else {
          outData(2, command, 0);               // иначе - сообщение пользователю "Неверные данные"
        }
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок запроса значения из EEPROM по адресу ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      case 0x21:                                     // если !            
        request(command);                                // 
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок запроса флагов состояний контроллера ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      case 0x3F:                                     // если ?            
        statesOfFlags(command);                                // 
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок вывода данных из рабочего массива :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  
      case 0x26:                                     // если &
            for (int i=0; i < (int)(sizeof(default_Array)/sizeof(int)); i++){
              btSerial.print(data_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок вывода данных из дефолтного массива :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  
      case 0x25:                                     // если %
            for (int i=0; i < (int)(sizeof(default_Array)/sizeof(int)); i++){
              btSerial.print(default_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок для вывода данных из EEPROM :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  
      case 0x7C:                                     // если |
        EEPROM.get(0,temp_Array);
            for (int i=0; i < (int)(sizeof(default_Array)/sizeof(int)); i++){
              btSerial.print(temp_Array[i]);
              btSerial.print(":");
              temp_Array[i] = 0;
            }
            btSerial.println();
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок сброса настроек к дефолту (обнуление ключа EEPROM, после перезагрузки контроллер подгрузит дефолтные значения) ::::::::://
      case 0x2A:                                       // если *
        EEPROM.put(1000,255);
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    ///::::::: Блок получения команд сценариев :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
       case 0x40:                                   // если @
        stop = false;                                      // снимаем СТОП-флаг
        scenarioParser(command);                           // парсим строку принятых данных
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  

    //::::::: Блок ошибки (если команда не распознана) :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      default:                                    // если совпадений нет
        outData(1, dataIn.substring(0, 1), 0);                 // сообщение пользователю "Неверная команда"
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
    }
    dataIn = "";                                  // обнуляем входные данные
    command = "";
}
//==========================================================================================================================================

//------------ Блок вывода значения из EEPROM по запросу -----------------------------------------------------------------------------------
void request (String comm){            // принимаем значение
  int t;
  int ini = comm.toInt();           // преобразовываем его в адрес
  EEPROM.get(ini*2, t);                 // вытаскиваем данные из EEPROM по данному адресу из массива
  btSerial.println(t);                  // отправляем значение
}
//==========================================================================================================================================

//------------ Блок вывода флагов состояний контроллера ------------------------------------------------------------------------------------
void statesOfFlags(String data){
  String temp = data;
  int val;
  if (data == "100") {
    for (int i=0; i < (int)(sizeof(Flags_Array)); i++){                      // весь массив флагов
      btSerial.print(Flags_Array[i]);                                            // передаем поочередно
      btSerial.print(":");                                                      // с разделителем ':'
    }
    btSerial.println();
  } else {
      val = data.toInt();
      val += 1;
      data = String(val);
      switch (temp.toInt()) {
        case 110:
          Flags_Array[0] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг StandBy
          break;
        case 120:
          Flags_Array[1] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг DefaultSettings
          break;
        case 130:
          Flags_Array[2] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг night
          break;
        case 140:
          Flags_Array[3] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг cycle_flag
          break;
        case 150:
          Flags_Array[4] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг UpFlag
          break;
        case 160:
          Flags_Array[5] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг DownFlag
          break;
        case 170:
          Flags_Array[6] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг AllFlag
          break;
        case 180:
          Flags_Array[7] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг DifferentFlag
          break;
        case 190:
          Flags_Array[8] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг TowardsFlag
          break;
        case 200:
          Flags_Array[9] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг SOSFlag
          break;
        case 210:
          Flags_Array[9] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг LuminescentFlag
          break;
        default:
          outData (2, temp, 0);                         // сообщение оператору "Неверные данные"
          break;
      }
  }
}

//==========================================================================================================================================


//------------ Блок парсера пользовательских настроек с записью в память и рабочий массив --------------------------------------------------
void getSettings (String data) {                      // получаем блок данных (строка с данными и разделителями)
  String temp;
  int addr, val;
  do {                                                        // выполнить
    if (data.indexOf(";", 0) != -1) {                             // если блок содержит хоть один разделитель ';' 
      temp = data.substring(0, data.indexOf(";", 0));                 // во временную переменную пишем подстроку до ближайшего разделителя ';'
      data.remove(0, data.indexOf(";", 0)+1);                         // обрезаем блок от начала вместе с разделителем ';'      
      if (temp[1] == ':' || temp[2] == ':') {                         // если 2-й или 3-й символ это разделитель ':'
        addr = temp.substring(0,temp.indexOf(":", 0)).toInt();          // записываем в переменную адрес (значение до разделителя ':')
        val = temp.substring(temp.indexOf(":", 0)+1).toInt();           // записываем в переменную само значение (после разделителя ':')
        if (addr == 99) {                                               // если адрес = 99 (спец.команда)
          onlineBright(val);                                              // то вызов функции немедленного изменения яркости
        } else {                                                        // иначе
          data_Array[addr] = val;                                         // пишем значение по указанному адресу в рабочий массив
          EEPROM.put((addr)*2,val);                                       // пишем значение по указанному адресу в EEPROM
        }
      }
    } else {                                                      
      outData(2, data, 0);                                        // иначе - сообщение пользователю "Неверные данные"
      break;
    }
  } while (data != "");                                       // повторяем цикл, пока не закончится блок с данными
  temp = "";                                                  // обнуляем переменные
  val = 0; 
  addr = 0;
}
//==========================================================================================================================================

//------------ Блок вывода сообщений пользователю ------------------------------------------------------------------------------------------
void outData (int value, String dataOut, byte additional){              // принимаем блок данных (вид сообщения, данные, дополнительные данные)
  switch (value) {                                        // ищем совпадения по значению
    case 1:                                                   // если 1, то 
      btSerial.print(100);              // вывод сообщения "Неверная команда" со значением команды
      break;
    case 2:                                                   // если 2, то 
      btSerial.print(200);              // вывод сообщения "Неверные данные" со значением
      break;
    case 3:                                                   // если 3, то 
      btSerial.print(300);              // вывод сообщения "Команда принята" со значением      
      break;
    case 4:                                                   // если 4, то
      btSerial.print(400);              // вывод сообщения "Команда выполнена" со значением
      break;
    case 5:
      btSerial.print(500);              // вывод сообщения "Состояние ОК" со значением ???????
      break;
    default:
      btSerial.print(600);                // внутренняя ошибка  ?????
  }
  btSerial.print(",");
  btSerial.println(dataOut);
/*  if (additional == 0 || additional == 1) {
    btSerial.print(",");
    btSerial.println(additional, HEX);
  }
*/
}
//==========================================================================================================================================

//------------ Блок парсера сценариев -------------------------------------------------------------------------------------------------------
void scenarioParser (String data){                                     // получаем данные
  String tempdata;
  String cycledata = data;                                  // сохраняем набор команд на случай зацикливания !
  dataIn = "";                                              // очищаем входные данные
  data_flag = false;
  do {                                                     
    if (stop){                                              // если флаг СТОП
    Flags_Array[3] = false;                                     // отмена зацикливания сценариев
    cycledata = "";                                         // переменную с набором команд тоже очищаем
    break;                                                  // выходим из цикла                     
    } 
    tempdata = data.substring(0, 1);                           // пишем в переменную первый символ
    data.remove(0,1);                                          // удаляем первый символ из набора команд
    switch (tempdata.charAt(0)) {                              // ищем совпадение по символу
      case 0x4F:                                                    // включение контроллера лестницы
        Flags_Array[0] = false;                                          // выход из режима ожидания (флаг StandBy)
        break;
      case 0x6F:                                                    // выключение контроллера лестницы
        Tlc.setAll(0);                                                // тушим все ступени
        Tlc.update();
        Flags_Array[0] = true;                                           // переход в режим ожидания (флаг StandBy)
        break;
      case 0x50:                                                    // команда ?????????????????????????????

        break;
      case 0x58:                                                    // запрос состояния контроллера лестницы
        statusMode();                                                 // функция ответа на запрос !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        break;
      case 0x55:                                                    // команда включения вверх
        up(0, data_Array[10], data_Array[14], 1);                     // включаем ступени последовательно вверх
        break;
      case 0x75:                                                    // команда выключения вверх
        up(data_Array[10], 0, data_Array[14], 0);                     // выключаем ступени последовательно вверх
        break;
      case 0x44:                                                    // команда включения вниз
        down(0, data_Array[10], data_Array[14], 1);                   // включаем ступени последовательно вниз
        break;
      case 0x64:                                                    // команда выключения вниз
        down(data_Array[10], 0, data_Array[14], 0);                   // выключаем ступени последовательно вниз
        break;
      case 0x41:                                                    // команда включения всех ступеней
        all(data_Array[10], 1);                                       // включаем все ступени разом
        break;
      case 0x61:                                                    // команда выключения всех ступеней
        all(0, 0);                                                    // выключаем все ступени разом
        break;
      case 0x46:                                                    // команда включения в разные стороны
        different(0, data_Array[10], data_Array[14], 1);              // включаем ступени от середины в разные стороны
        break;
      case 0x66:                                                    // команда выключения в разные стороны
        different(data_Array[10], 0, data_Array[14], 0);              // выключаем ступени от середины в разные стороны
        break;
      case 0x54:                                                    // команда включения навстречу
        towards(0, data_Array[10], data_Array[14], 1);                // включаем ступени навстречу с разных сторон
        break;
      case 0x74:                                                    // команда выключения навстречу
        towards(data_Array[10], 0, data_Array[14], 0);                // выключаем ступени навстречу с разных сторон
        break;
      case 0x53:                                                    // SOS
        sos(4095, 0);                                                 // режим SOS, (максимальная яркость, зациклить- 1 или один раз- 0)
        break;
      case 0x4C:                                                    // режим люминесцентной лампы
        luminescent(data_Array[10]);                                  // включаем все ступени с эффектом люминесцентной лампы
        break;
      case 0x43:                                                    // зациклить сценарии
        Flags_Array[3] = true;
        break;
      case 0x63:                                                    // отмена зацикливания сценариев  ------ вероятно, не нужен, проверить           ??????
        Flags_Array[3] = false;
        break;
      default:                                                      // если совпадений нет
        outData (2, tempdata, 0);                         // сообщение оператору "Неверные данные"
        break;
    }     
    if (Flags_Array[3] && data == "") {                       // если установлен флаг зацикливания и команды закончились
      data = cycledata;                                     // восстанавливаем набор команд
    }
  } while (data != "");                                   // пока не кончатся команды
  stop = false;
}
//==========================================================================================================================================

//-------------Изменение яркости "на лету"---------------------------------------------------------------------------------------------------
void onlineBright (int val) {
    for (int i = 0; i <= data_Array[8]; i++) {
      Tlc.set(i, val);
  }
  Tlc.update();
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней снизу вверх ------------------------------------------------------------------------------------
void up (int initVal, int target, int stepPWM, bool state) {          // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
    outData(3, state ? "U" : "u", state);                             // ответ пользователю, что команда выполняется
    for (int step = 0; step < data_Array[8]; step ++) {                 // начиная с 0 увеличиваем ступень на 1
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния ---- проверить stepPWM - должен до 0 !!!!
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if (Tlc.get(step) >= (uint16_t)target && state) break;                    // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
	      }
   }
   outData(4, state ? "U" : "u", state);                             // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней сверху вниз -----------------------------------------------------------------------------------
void down (int initVal, int target, int stepPWM, bool state) {        // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
    outData(3, state ? "D" : "d", state);                             // ответ пользователю, что команда выполняется
    for (int step = data_Array[8] - 1; step >= 0; step --) {               // начиная с последней уменьшаем ступень на 1
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM :u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if ((Tlc.get(step) >= (uint16_t)target) && state) break;                    // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
	      }
    }
    outData(4, state ? "D" : "d", state);                             // ответ пользователю, что команда выполнена 
}
//==========================================================================================================================================

//------------ Включение/выключение всех ступеней разом ------------------------------------------------------------------------------------
void all (int bright, bool state) {                                     // параметры (яркость, состояние 0-выключить, 1-включить)
  outData(3, state ? "A" : "a", state);                                   // ответ пользователю, что команда выполняется
  DataSerialAvailable();                                            // проверяем, есть ли данные на входе
  if (stop) {                                                       // если флаг СТОП
    actionSTOP();                                                         // вызываем функцию СТОП
    return;                                                          // выходим из цикла
  }      
  Tlc.setAll(bright);                                                       // всем ступеням назначаем указанную яркость
  for (int i = 0; i <= data_Array[8]; i++) {
    interceptorArray[i][1] = bright;
  }
  Tlc.update();                                                             // применяем изменения
  outData(4, state ? "A" : "a", state);                                   // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней от середины к краям ---------------------------------------------------------------------------
void different (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  int up, down;
  outData(3, state ? "F" : "f", state);                                   // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                            // вычисляем среднюю ступень

    for (up = center, center % 2 == 0 ? down = center - 1: down = center; up < data_Array[8]; up ++, down --) {   // отсчет ведем в зависимости от четности ступеней 
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
        if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
        if ((Tlc.get(up) == (uint16_t)target || Tlc.get(down) == (uint16_t)target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей вверх
          Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей вниз
          Tlc.update();                                                  // применяем изменения
          delay(data_Array[15]);                                         // применяем установленную задержку
      } 
    } 
    outData(4, state ? "F" : "f", state);                                   // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней от краев навстречу друг другу ----------------------------------------------------------------- 
void towards (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  outData(3, state ? "T" : "t", state);                                  // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                           // вычисляем среднюю ступень
    for (int up = 0, down = data_Array[8] - 1; center % 2 == 0 ? up < center: up <= center; up ++, down --) {   // в зависимости от четности ступеней устанавливаем среднюю ступень
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
        if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
        if ((Tlc.get(up) == (uint16_t)target || Tlc.get(down) == (uint16_t)target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей сверху
          Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей снизу
          Tlc.update();                                                  // применяем изменения
          delay(data_Array[15]);                                         // применяем установленную задержку
      }
    }
    outData(4, state ? "T" : "t", state);                                  // ответ пользователю, что команда выполняется 
}
//==========================================================================================================================================

//------------ Включение режима SOS --------------------------------------------------------------------------------------------------------
void sos (int bright, bool state) {                                  // параметры (яркость, состояние 1-включить)
  outData(3, "S", state);                                              // ответ пользователю, что команда выполняется

  byte cycle = 0;                                                       // 
  byte on = 0;
  int pause = 200;                                                      // задаем значение паузы
        Tlc.setAll(0);                                                  // выключаем все ступени
        Tlc.update();
  delay (1000);                                                         // пауза перед включением

  while (cycle < 3) {                                                   // если прошло менее трех циклов, то
    if (cycle == 2) {                                                     // если уже третий цикл
      delay (pause);                                                        // применяем паузу
      pause = 200;                                                          // меняем значение паузы
    }
    do {                                                                  // выполняем код ниже до условия
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      delay (pause);                                                        // пауза
        Tlc.setAll(bright);                                                 // устанавливаем всем ступеням указанную яркость
        Tlc.update();                                                       // применяем изменения
      delay (pause);                                                        // пауза
        Tlc.setAll(0);                                                      // тушим все ступени
        Tlc.update();                                                       // применяем изменения
       on ++;                                                               // увеличиваем счетчик
    } while (on < 3);                                                     // условие - пока счетчик менее трех
    on = 0;                                                               // сбрасываем счетчик
    pause = 500;                                                          // меняем значение паузы
    cycle ++;                                                             // увеличиваем общий счетчик циклов
  }
  outData(4, "S", state);                                              // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение ступеней имитируя люминесцентную лампу ----------------------------------------------------------------------------
void luminescent (int bright) {                                      // параметры (яркость)

  byte f = 0;
  int pause = 1000;
  outData(3, "L", 1);                                              // ответ пользователю, что команда выполняется

  Tlc.setAll(0);
  Tlc.update();
  for (int first = 0, last = data_Array[8] - 1, b = 0; b <= bright ; b ++) {
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
    Tlc.set(first, b);
    Tlc.set(last, b);
    Tlc.update();
    delayMicroseconds(500);
  } 

  Tlc.setAll(bright);
  Tlc.update();
  delay(700);
  
  do {
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
    Tlc.setAll(bright/8);
    Tlc.update();

      delay(pause/2);

    for (int b = bright/8; b < bright; b ++) {
      Tlc.setAll(b);
      Tlc.update();
    }

    pause /= 4;
    f ++;
    delay(pause);
  } while (f < 5);

  outData(4, "L", 1);                                              // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Проверка сенсоров -----------------------------------------------------------------------------------------------------------
int sensorsCheck (Ultrasonic sensor, int operateNumber) {
  byte tempNumber = operateNumber;
  int dist_3[3] = {0, 0, 0};                        // массив для хранения трёх последних измерений
  int dist = 0;                                         // переменная для текущей дистанции
  int result = 0;

  do {
    for (int i = 0; i < 3; i++) {                    // счётчик от 0 до 2
      dist_3[i] = sensor.Ranging(CM);                  // пишем дистанцию с датчика (в см.) в текущую ячейку массива
      delay(data_Array[5]);                            // небольшая задержка необходима, чтобы эхо предыдущего сигнала не искажало текущий
    }
      dist = middle(dist_3[0], dist_3[1], dist_3[2]);    // фильтровать медианным фильтром из 3ёх последних измерений
      result += dist;
      tempNumber --;
  } while (tempNumber > 0);
    result = result / operateNumber;   
    return result;                                  // вернем в функцию отфильтрованное значение дистанции
}
//==========================================================================================================================================

//------------ медианный фильтр из 3ёх значений --------------------------------------------------------------------------------------------
int middle(int a, int b, int c) {
  int middle;
  if ((a <= b) && (a <= c)) {                 // если a <= b и a <= c
    middle = (b <= c) ? b : c;                  // среднее равно b, если b <= c или c, если c < b
  }
  else if ((b <= a) && (b <= c)) {            // если b <= a и b <= c
      middle = (a <= c) ? a : c;                // среднее равно a, если a <= c или c, если c < a
    }
    else {                                    // если c <= a и c <= b
      middle = (a <= b) ? a : b;                // среднее равно a, если a <= b или b, если b < a
    }
  return middle;                              // вернем в функцию среднее значение
}
//==========================================================================================================================================

//------------ Проверка Темно или Светло ---------------------------------------------------------------------------------------------------
boolean DarkOrLight() {  // создаем булеву функцию проверки показаний фоторезистора (день или ночь)

    int FotoElem = 0;                       // переменная для снятия показаний фоторезистора;
    int a = 0, b = 0;                                // переменные для гистерезиса (а-включение-ночь, b-выключение-день)

    for(int i = 0; i < 1000; i++) {                  // запускаем счетчик от "0" до "1000"
        FotoElem = analogRead(FOTO);                     // пишем в переменную текущеее значение с фоторезистора
        if (FotoElem > data_Array[0]) {                  // если значение фоторезистора больше (темнее) референсного значения;
            a++;                                            // увеличиваем a
            b = 0;                                          // обнуляем b
          } else if (FotoElem < (data_Array[0] - data_Array[1])) {       // иначе, если значение меньше (светлее), чем референсное значение минус допуск на гистерезис;
            b++;                                            // увеличиваем b
            a = 0;                                          // обнуляем a
          }
      }
    if (!dark && (a > 999)) {                        // если светло и a больше 999
         dark = true;                                   // устанавливаем - темно!
      } else if (dark && (b > 999)) {                // иначе, если темно и b больше 999
         dark = false;                                  // устанавливаем - светло!
      } else {                                       // в остальных случаях
        a = 0;                                          // обнуляем a, b
        b = 0;
      }
    return dark;                                      // возвращаем в функцию значение темно или светло!
 }
//==========================================================================================================================================

//------------ Проверка День или Ночь ------------------------------------------------------------------------------------------------------
boolean DayOrNight() {  // создаем булеву функцию проверки показаний фоторезистора (день или ночь)
  
  currentTime = millis();                           // сохраняем в переменную текущее время в мс.

  if (currentTime - startTime >= 1000UL) {          // если разница между временем старта и текущим временем более или равна 1 сек.
    startTime = currentTime;                        // стартовое время скинем до текущего

    switch (DarkOrLight()) {                           // запускаем проверку светло/темно 
      case true:                  // если темно
        if (Flags_Array[2]){                 // и если ночь (флаг night)
          Flags_Array[2] = true;               // подтверждаем ночь
          darkness = 0;               // обнуляем счетчик темноты
        } else darkness --;         // иначе, если день, уменьшаем счетчик темноты
        break;
      case false:                 // если светло
        if (!Flags_Array[2]){               // и если день
          Flags_Array[2] = false;              // подтверждаем день
          darkness = 0;              // обнуляем счетчик темноты
        } else darkness ++;;       // иначе, если ночь,  увеличиваем счетчик темноты
        break;
    }
              // дополнительный фильтр день/ночь на случая кратковременных изменений (облака, тени и т.д.)
      if (darkness == -5) {       // если счетчик темноты достиг -5
        darkness = 0;               // обнуляем счетчик темноты
        Flags_Array[2] = true;               // устанавливаем ночь
      }
      if (darkness == 5) {        // если счетчик темноты достиг 5
        darkness = 0;               // обнуляем счетчик темноты
        Flags_Array[2] = false;              // устанавливаем день
      } 
  }
  return Flags_Array[2];
 }
//==========================================================================================================================================

//------------ Дежурное освещение ----------------------------------------------------------------------------------------------------------
void emergencyLighting() {
  Tlc.set(0, data_Array[9]);
  Tlc.set(data_Array[8] - 1, data_Array[9]);
  Tlc.update();
}
//==========================================================================================================================================

//------------ Ответ на запрос состояния ---------------------------------------------------------------------------------------------------
void statusMode() {
  btSerial.print("OK");
}
//==========================================================================================================================================

//------------ СТОП всех выполняемых команд ------------------------------------------------------------------------------------------------
void actionSTOP() {
 //  stop = true;                                    // поднимаем флаг СТОП  
  Tlc.setAll(0);                                                       // всем ступеням назначаем указанную яркость
  Tlc.update();                                                             // применяем изменения
  outData(4, "$",  0);                         // ответ - команда выполнена
}
//==========================================================================================================================================
