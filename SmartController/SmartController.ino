#include "Tlc5940.h"                  // подключаем библиотеку драйвера
#include "Ultrasonic.h"               // подключаем библиотеку ультразвуковых датчиков
#include <EEPROM.h>
#include <SoftwareSerial.h>

#define T1 6                          // устанавливаем контакты для верхнего датчика
#define E1 5                          // устанавливаем контакты для верхнего датчика
#define T2 7                          // устанавливаем контакты для нижнего датчика
#define E2 8                          // устанавливаем контакты для нижнего датчика
#define FOTO A1                       // устанавливаем контакт для фоторезистора
Ultrasonic TopSensor(T1, E1);         // определяем нижний датчик
Ultrasonic BottomSensor(T2, E2);      // определяем верхний датчик


boolean Flags_Array[11];              // массив флагов текущих состояний системы (порядок см. ниже) 1-включен, 0-выключен;
//[0]-StandbyMode; [1]-DefaultSettings; [2]-night; [3]-cycle_flag; [4]-UpFlag; [5]-DownFlag; [6]-AllFlag; [7]-DifferentFlag; [8]-TowardsFlag; [9]-SOSFlag; [10]-LuminescentFlag;

// внутренние флаги //
boolean stop = 0;                     // флаг для остановки всех задач по входной команде 0х24 ($)
boolean dark = 0;                     // переключатель, если 0 - то темно, 1 - светло
boolean tumbler = 0;                  // флаг работы выключателя всей лестницы
boolean allStair = 0;                 // флаг срабатывания функции allStairWork()
boolean data_flag = false;			  // флаг выборки данных из приемного буфера в переменную

int tumblerCount = 0;                 // счетчик работы выключателя
int darkness = 0;                     // накопительная переменная для проверки день - ночь

// переменные для работы с счетчиками времени
unsigned long currentTime = 1UL;
unsigned long startTime = 1UL;
unsigned long currentMotionTime = 1UL;
unsigned long startMotionTime = 1UL;
unsigned long standByTime = 1UL;
unsigned long currentStandByTime = 1UL;

String dataCollect = "";			  // промежуточная строка при приеме длинного пакета данных
String dataIn = "";                   // переменная для входных данных


SoftwareSerial btSerial(2, 4); 		  // RX, TX - ноги контроллера для связи с BLE устройством

int default_Array[17] = {980,10,80,90,7,50,2000,1,16,200,1900,50,3000,10000,50,10,9};   // дефолтные настройки
int data_Array[sizeof(default_Array)];     // рабочий массив с настройками
int temp_Array[sizeof(default_Array)];     // временный массив для вывода данных из EEPROM при запросе
// int user_Array[17] лежит в EEPROM по адресу 0.

// Состав default_Array // Изменяемые настройки:
//==========================================================================================================================================
	// настройки фоторезистора //
//unsigned int dark = 980;              [0] референсное значение фоторезистора, выше которого считается ночь;
//int hysteresis = 10;                  [1] гистерезис переключения ночь-день
	//настройки ультразвуковых датчиков //
//int distanceTopOperate = 80;          [2] расстояние, при котором сработает верхний датчик, (см)
//int distanceBottomOperate = 90;       [3] расстояние, при котором сработает нижний датчик, (см)
//int distanceSwitch = 7;               [4] расстояние, меньше которого сработает выключатель (включение/выключение всей лестницы), (см)
//int ZadergkaSensora = 50;             [5] задержка между выстрелами сенсоров, (миллисекунды)                                              ---------   установить интервал от 15 - и выше.
//int sensorPollingDelay = 2000;        [6] интервал задержки срабатывания датчиков, чтобы одно пересечение не считалось за несколько, (миллисекунды)
//byte operateNumber = 1;               [7] количество срабатываний датчика для запуска функций (защита от случайных срабатываний и эл.магн. помех)
	// настройки свечения ступеней //
//byte numberOfSteps = 16;              [8] количество ступеней лестницы, (шт.)
//int emergencyLighting = 200;          [9] яркость первой и последней ступенек в ночном режиме, (дежурное освещение)
//int maxBrightness = 1900;             [10] максимальная яркость свечения, (min 0 - 4095 max)
//int delaySwitchingNextStep = 50;      [11] задержка перед включением/выключением следующей ступени, (миллисекунды)
//int timeGlowStep = 3000; 			    [12] задержка свечения ступеней перед последовательным выключением, (миллисекунды)
//int timeAllSteps = 10000;             [13] задержка свечения всей лестницы, (миллисекунды)
//int stepPWM = 50;                     [14] шаг увеличения яркости ШИМ, (min 0 - 4095 max)
//int delayPWM = 10;                    [15] задержка между шагами ШИМ (плавное включение), (миллисекунды) нельзя устанавливать 0
//byte landing = 9;                     [16] площадка разворота лестницы, (№ ступени)
//==========================================================================================================================================

// --------- Инициализация -----------------------------------------------------------------------------------------------------------------
void setup() {
  if (EEPROM.read(1000) != 123){                    // если по адресу 1000 нет ключа со значением 123 (первый запуск) // (при запросе учитывать, что ячейки  двухбайтовые - адрес 500)
    EEPROM.write(1000, 123);                        // запишем ключ
    EEPROM.put(0, default_Array);                   // запишем в память массив с дефолтными настройками, начиная с адреса 0
  }

  Serial.begin(9600);         // раскоментировать для отладки

  Tlc.init(0);                                      // гасим все ступени
  btSerial.begin(57600);                            // открываем последовательный порт на скорости 57600
  EEPROM.get(0, data_Array);                      	// загружаем из памяти в рабочий массив настройки пользователя
  startTime = millis();                             // сохраняем в переменную время старта в мс.

    for (int i=0; i <= (int)(sizeof(Flags_Array)); i++){	// обнуляем все флаги состояний системы
      Flags_Array[i] = 0;
    }

}
//==========================================================================================================================================

//----------- Основной цикл ----------------------------------------------------------------------------------------------------------------
void loop() {
  
  if (Flags_Array[0] == true) {                                                // если StandBy режим
    currentStandByTime = millis();                                              // пишем текущее время в переменную
    if (currentStandByTime - standByTime >= 30000) Flags_Array[0] = false;      // если время входа в режим StandBy больше текущего времени на 30 сек., снимаем флаг StandBy
  }

  if (DataSerialAvailable()) {                         // проверяем, если data_flag установлен
      data_flag = false;                                   // сбрасываем флаг
      DataParse();                                         // парсим входные данные
  } else {


      if (!Flags_Array[0] && DayOrNight()) {              // если Ночь и не режим ожидания 
        if (!tumbler) emergencyLighting(1);                 // если не режим выключатель, включаем дежурную подсветку крайних ступеней
        stop = false;                                       // снимаем СТОП-флаг
        allStair = false;												            // снимаем флаг функции allStairWork()

        int top = sensorsCheck(TopSensor, data_Array[7]);           // опрашиваем верхний датчик
        int bottom = sensorsCheck(BottomSensor, data_Array[7]);     // опрашиваем нижний датчик

        if (bottom < data_Array[4] || top < data_Array[4]) {			// если нижний или верхний меньше расстояния для выключателя
            tumblerCount ++;												                // увеличиваем счетчик выключателя
            if (tumbler && tumblerCount == 5) {								      // если режим выключатель уже включен и счетчик достиг 5
              all(0, 0);														                  // выключаем все ступени
              tumbler = 0;													                  // сбрасываем флаг выключателя
              tumblerCount = 0;												                // сбрасываем счетчик
            } else if (!tumbler && tumblerCount == 5) {					    // если режим выключатель выключен и счетчик достиг 5
              all(data_Array[10], 1);											            // включаем все ступени
              tumbler = 1;													                  // поднимаем флаг выключателя
              tumblerCount = 0;												                // сбрасываем счетчик
            }
        } else tumblerCount = 0;										              // сбрасываем счетчик

        if (!tumbler && bottom > data_Array[4] && bottom <= data_Array[3]) {		// если не режим выключателя, а нижний датчик больше расстояния выключателя и меньше установленного
          startMotionTime = millis();										                          // пишем время старта
          up(0, data_Array[10], data_Array[14], 1, 1);					                  // запускаем включение лестницы вверх
          delay (data_Array[12]);
          if (!allStair) {												                                // если не включена вся лестница
            allStair = false;												                                // снимаем флаг функции allStairWork()
            up(data_Array[10], 0, data_Array[14], 0, 1);					                  // запускаем тушение лестницы вверх
          }
          
        } else if (!tumbler && top > data_Array[4] && top <= data_Array[2]) {		  // аналогично с нижним датчиком
            startMotionTime = millis();
            down(0, data_Array[10], data_Array[14], 1, 1);
            delay (data_Array[12]);
            if (!allStair) {
              allStair = false;
              down(data_Array[10], 0, data_Array[14], 0, 1);
            }
          }

      } else if (!Flags_Array[0] && !tumbler) {                                   // если не режим ожидания и не режим выключателя
            Tlc.setAll(0);                                                          // если День - тушим все ступени
            Tlc.update();                                                           // применяем изменения
        }
    }
}
//==========================================================================================================================================

//--------- Проверка наличия входных данных ------------------------------------------------------------------------------------------------
boolean DataSerialAvailable(){  
  while (btSerial.available()>0){                // если данные поступили
      dataIn += (char)btSerial.read();              // набиваем переменную данными
      data_flag = true;                             // устанавливаем флаг, что данные получены
      delay(1);                                     // маленькая задержка (без нее коряво работает)
  }

  // здесь проверяем длинные пакеты с данными для настроек. Общий пакет разбит на части по 20 Байт и содержит дополнительные символы //  
  if (dataIn.endsWith("^")) {                        // если принятая строка заканчивается на промежуточный символ "^"
      dataCollect += dataIn.substring(0, dataIn.length() - 1);     // сохраняем строку без последнего символа   
      dataCollect.replace("^",""); 
      dataIn = "";                                                    // очищаем входную строку
      data_flag = false;                                              // снимаем флаг
    if (dataCollect.endsWith("|")) {                                // если строка заканчивается "|" (конец посылки)
      dataCollect = dataCollect.substring(1, dataCollect.length() - 2);       // обрезаем первый (#) и два последних символа (#|) строки
      outData(3, "Set.receive", 0);
//      Serial.print("dataCollect : ");
//      Serial.println(dataCollect);
      getSettings(dataCollect);                                         // парсим строку
      dataCollect = "";                                             // обнуляем накопленную подстроку
      }
  } else if (dataIn.length() >= 20) outData(2, dataIn,0);

  if (dataIn.indexOf("$") != -1) {              // если строка содержит символ '$'
    stop = true;									                  // поднимаем СТОП-флаг
    dataIn = "";                                    // очищаем входные данные
    data_flag = false;
  }
  
  if (dataIn == "@X") {                         // если строка = @X - опрос состояния
    statusMode();                                   // отвечаем на запрос
    dataIn = "";                                    // очищаем входные данные
    data_flag = false;
  }
  return data_flag;
}
//==========================================================================================================================================

//--------- Блок разбора полученных данных -------------------------------------------------------------------------------------------------
void DataParse() {

    String command = dataIn.substring(1);           // переносим данные в новую переменную без первого символа 
    
    switch ((uint8_t)dataIn[0]){                             // ищем совпадение по первому символу (в полной строке)
    //::::::: Блок разбора и сохранения настроек ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      case 0x23:                                     // если #
        if (command.endsWith("#")) {                              // если строка заканчивается #
          command = command.substring(0, command.length() - 1);       // обрезаем последний символ строки            
          getSettings(command);                                       // парсим строку
        } else {
          outData(2, command, 0);               // иначе - сообщение пользователю "Неверные данные"
        }
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок запроса значения из EEPROM по адресу ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      case 0x21:                                     // если !            
        request(command);                                // запрашиваем нужные данные из EEPROM 
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок запроса флагов состояний контроллера ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      case 0x3F:                                     // если ?            
        statesOfFlags(command);                          // запрашиваем нужные флаги состояний
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок вывода данных из рабочего массива :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  
      case 0x26:                                     // если &
            for (int i=0; i < (int)(sizeof(default_Array)/sizeof(int)); i++){		// вернем целиком рабочий массив
              btSerial.print(data_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
                break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок вывода данных из дефолтного массива :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  
      case 0x25:                                     // если %
            for (int i=0; i < (int)(sizeof(default_Array)/sizeof(int)); i++){	// вернем целиком дефолтный массив
              btSerial.print(default_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок для вывода данных из EEPROM :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  
      case 0x7C:                                     // если |
        EEPROM.get(0,temp_Array);
            for (int i=0; i < (int)(sizeof(default_Array)/sizeof(int)); i++){	// вернем целиком массив из EEPROM
              btSerial.print(temp_Array[i]);
              btSerial.print(":");
              temp_Array[i] = 0;
            }
            btSerial.println();
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    //::::::: Блок сброса настроек к дефолту (обнуление ключа EEPROM, после перезагрузки контроллер подгрузит дефолтные значения) ::::::::://
      case 0x2A:                                       // если *
        EEPROM.put(1000,255);								// затираем ключ
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

    ///::::::: Блок получения команд сценариев :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
       case 0x40:                                   // если @
        stop = false;                                      // снимаем СТОП-флаг
        scenarioParser(command);                           // парсим строку принятых данных
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://  

    //::::::: Блок ошибки (если команда не распознана) :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
      default:                                    // если совпадений нет
        outData(1, dataIn.substring(0, 1), 0);                 // сообщение пользователю "Неверная команда"
        break;
    //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
    }
    dataIn = "";                                  // обнуляем входные данные
    command = "";
}
//==========================================================================================================================================

//------------ Блок вывода значения из EEPROM по запросу -----------------------------------------------------------------------------------
void request (String comm){            // принимаем значение
  int t;
  int ini = comm.toInt();           // преобразовываем его в адрес
  EEPROM.get(ini*2, t);                 // вытаскиваем данные из EEPROM по данному адресу из массива
  btSerial.println(t);                  // отправляем значение
}
//==========================================================================================================================================

//------------ Блок вывода флагов состояний контроллера ------------------------------------------------------------------------------------
void statesOfFlags(String data){
  String temp = data;
  int val;
  if (data == "100") {													// если запрос 100
    for (int i=0; i < (int)(sizeof(Flags_Array)); i++){                      // весь массив флагов
      btSerial.print(Flags_Array[i]);                                           // передаем поочередно
      btSerial.print(":");                                                      // с разделителем ':'
    }
    btSerial.println();
  } else {																// иначе разбираем запрос
      val = data.toInt();
      val += 1;
      data = String(val);
      switch (temp.toInt()) {
        case 110:
          Flags_Array[0] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг StandBy
          break;
        case 120:
          Flags_Array[1] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг DefaultSettings
          break;
        case 130:
          Flags_Array[2] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг night
          break;
        case 140:
          Flags_Array[3] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг cycle_flag
          break;
        case 150:
          Flags_Array[4] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг UpFlag
          break;
        case 160:
          Flags_Array[5] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг DownFlag
          break;
        case 170:
          Flags_Array[6] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг AllFlag
          break;
        case 180:
          Flags_Array[7] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг DifferentFlag
          break;
        case 190:
          Flags_Array[8] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг TowardsFlag
          break;
        case 200:
          Flags_Array[9] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг SOSFlag
          break;
        case 210:
          Flags_Array[9] ? outData(4, data, 0) : outData(4, temp, 0);         // флаг LuminescentFlag
          break;
        default:
          outData (2, temp, 0);                         // сообщение оператору "Неверные данные"
          break;
      }
  }
}

//==========================================================================================================================================


//------------ Блок парсера пользовательских настроек с записью в память и рабочий массив --------------------------------------------------
void getSettings (String data) {                      // получаем блок данных (строка с данными и разделителями)
  String temp;
  int addr, val;
  do {                                                        // выполнить
    if (data.indexOf(";", 0) != -1) {                             // если блок содержит хоть один разделитель ';' 
      temp = data.substring(0, data.indexOf(";", 0));                 // во временную переменную пишем подстроку до ближайшего разделителя ';'
      data.remove(0, data.indexOf(";", 0)+1);                         // обрезаем блок от начала вместе с разделителем ';'      
      if (temp[1] == ':' || temp[2] == ':') {                         // если 2-й или 3-й символ это разделитель ':'
        addr = temp.substring(0,temp.indexOf(":", 0)).toInt();          // записываем в переменную адрес (значение до разделителя ':')
        val = temp.substring(temp.indexOf(":", 0)+1).toInt();           // записываем в переменную само значение (после разделителя ':')
        if (addr == 99) {                                               // если адрес = 99 (спец.команда)
          onlineBright(val);                                              // то вызов функции немедленного изменения яркости
        } else {                                                        // иначе
          data_Array[addr] = val;                                         // пишем значение по указанному адресу в рабочий массив
          EEPROM.put((addr)*2,val);                                       // пишем значение по указанному адресу в EEPROM
        }
      }
    } else {                                                      
      outData(2, data, 0);                                        // иначе - сообщение пользователю "Неверные данные"
      break;
    }
  } while (data != "");                                       // повторяем цикл, пока не закончится блок с данными

  if (addr != 99) {
    outData(4, "Set.get", 0);                                   // ответ пользователю, что настройки применены
    all(0, 0);                                                      // выключаем все, чтобы в следующем рабочем цикле применились новые настройки
  }
  
  temp = "";                                                  // обнуляем переменные
  val = 0; 
  addr = 0;
}
//==========================================================================================================================================

//------------ Блок вывода сообщений пользователю ------------------------------------------------------------------------------------------
void outData (int value, String dataOut, byte additional){              // принимаем блок данных (вид сообщения, данные, дополнительные данные)
  switch (value) {                                        // ищем совпадения по значению
    case 1:                                                   // если 1, то 
      btSerial.print(100);              // вывод сообщения "Неверная команда" со значением команды
      break;
    case 2:                                                   // если 2, то 
      btSerial.print(200);              // вывод сообщения "Неверные данные" со значением
      break;
    case 3:                                                   // если 3, то 
      btSerial.print(300);              // вывод сообщения "Команда принята" со значением      
      break;
    case 4:                                                   // если 4, то
      btSerial.print(400);              // вывод сообщения "Команда выполнена" со значением
      break;
    case 5:
      btSerial.print(500);              // вывод сообщения "Состояние ОК" со значением ???????
      break;
    default:
      btSerial.print(600);                // внутренняя ошибка  ????? резерв ???
  }
  btSerial.print(",");
  btSerial.println(dataOut);
}
//==========================================================================================================================================

//------------ Блок парсера сценариев -------------------------------------------------------------------------------------------------------
void scenarioParser (String data){                                     // получаем данные
  String tempdata;
  String cycledata = data;                                  // сохраняем набор команд на случай зацикливания !
  dataIn = "";                                              // очищаем входные данные
  data_flag = false;
  do {                                                     
    if (stop){                                              // если флаг СТОП
		Flags_Array[3] = false;                                 // отмена зацикливания сценариев
		cycledata = "";                                         // переменную с набором команд тоже очищаем
		break;                                                  // выходим из цикла                     
    } 
    tempdata = data.substring(0, 1);                           // пишем в переменную первый символ
    data.remove(0,1);                                          // удаляем первый символ из набора команд
    switch (tempdata.charAt(0)) {                              // ищем совпадение по символу
      case 0x4F:                                                    // включение контроллера лестницы
        Flags_Array[0] = false;                                        // выход из режима ожидания (флаг StandBy)
        break;
      case 0x6F:                                                    // выключение контроллера лестницы
        Tlc.setAll(0);                                                // тушим все ступени
        Tlc.update();
        standByTime = millis();											// запоминаем время старта режима StandBy
        Flags_Array[0] = true;                                          // переход в режим ожидания (флаг StandBy)
        break;
      case 0x50:                                                    // команда ?????????????????????????????

        break;
      case 0x58:                                                    // запрос состояния контроллера лестницы
        dataIn = "";
        statusMode();                                                 // функция ответа на запрос 
        break;
      case 0x55:                                                    // команда включения вверх
        up(0, data_Array[10], data_Array[14], 1, 0);                     // включаем ступени последовательно вверх
        break;
      case 0x75:                                                    // команда выключения вверх
        up(data_Array[10], 0, data_Array[14], 0, 0);                     // выключаем ступени последовательно вверх
        break;
      case 0x44:                                                    // команда включения вниз
        down(0, data_Array[10], data_Array[14], 1, 0);                   // включаем ступени последовательно вниз
        break;
      case 0x64:                                                    // команда выключения вниз
        down(data_Array[10], 0, data_Array[14], 0, 0);                   // выключаем ступени последовательно вниз
        break;
      case 0x41:                                                    // команда включения всех ступеней
        all(data_Array[10], 1);                                       // включаем все ступени разом
        break;
      case 0x61:                                                    // команда выключения всех ступеней
        all(0, 0);                                                    // выключаем все ступени разом
        break;
      case 0x46:                                                    // команда включения в разные стороны
        different(0, data_Array[10], data_Array[14], 1);              // включаем ступени от середины в разные стороны
        break;
      case 0x66:                                                    // команда выключения в разные стороны
        different(data_Array[10], 0, data_Array[14], 0);              // выключаем ступени от середины в разные стороны
        break;
      case 0x54:                                                    // команда включения навстречу
        towards(0, data_Array[10], data_Array[14], 1);                // включаем ступени навстречу с разных сторон
        break;
      case 0x74:                                                    // команда выключения навстречу
        towards(data_Array[10], 0, data_Array[14], 0);                // выключаем ступени навстречу с разных сторон
        break;
      case 0x53:                                                    // SOS
        sos(4095, 0);                                                 // режим SOS, (максимальная яркость, зациклить- 1 или один раз- 0)
        break;
      case 0x4C:                                                    // режим люминесцентной лампы
        luminescent(data_Array[10]);                                  // включаем все ступени с эффектом люминесцентной лампы
        break;
      case 0x43:                                                    // зациклить сценарии
        Flags_Array[3] = true;
        break;
      case 0x63:                                                    // отмена зацикливания сценариев
        Flags_Array[3] = false;
        break;
      default:                                                      // если совпадений нет
        outData (2, tempdata, 0);                         // сообщение оператору "Неверные данные"
        break;
    }     
    if (Flags_Array[3] && data == "") {                       // если установлен флаг зацикливания и команды закончились
      data = cycledata;                                     // восстанавливаем набор команд
    }
  } while (data != "");                                   // пока не кончатся команды
  stop = false;
}
//==========================================================================================================================================

//-------------Изменение яркости "на лету"---------------------------------------------------------------------------------------------------
void onlineBright (int val) {
    for (int i = 0; i <= data_Array[8]; i++) {		// всем ступеням присваиваем нужную яркость
      Tlc.set(i, val);
  }
  Tlc.update();
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней снизу вверх ------------------------------------------------------------------------------------
void up (int initVal, int target, int stepPWM, bool state, bool work) {   // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить, 1-вызов из рабочего цикла, 0- из настроек)
    outData(3, state ? "U" : "u", state);                             // ответ пользователю, что команда выполняется
    for (int step = 0; step < data_Array[8]; step ++) {                 // начиная с 0 увеличиваем ступень на 1
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                      // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if (Tlc.get(step) >= (uint16_t)target && state) break;          // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
      }   
      if (work) {														// при вызове из рабочего цикла
        if (TopSensor.Ranging(CM) <= data_Array[2] || BottomSensor.Ranging(CM) <= data_Array[3]) {		// если сработал любой из датчиков
          currentMotionTime = millis();																		// запоминаем текущее время 
          if (currentMotionTime - startMotionTime >= data_Array[6]) {										// если текущее время больше времени старта на установленное значение
            startMotionTime = currentMotionTime;																// сбросим стартовое время
            allStairWork();																						// вызываем ф-ю включения всей лестницы
            return;
          }   
        }
      
      if (step == data_Array[16] - 1) delay(data_Array[11] * 10);		// если достигли ступени-платформы разворота, задержка умноженная на 10
      else delay(data_Array[11]);											// для других ступеней обычная задержка
      }
   
   }
   outData(4, state ? "U" : "u", state);                             // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней сверху вниз -----------------------------------------------------------------------------------
void down (int initVal, int target, int stepPWM, bool state, bool work) {   // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить, 1-вызов из рабочего цикла, 0- из настроек)
    outData(3, state ? "D" : "d", state);                             // ответ пользователю, что команда выполняется
    for (int step = data_Array[8] - 1; step >= 0; step --) {            // начиная с последней уменьшаем ступень на 1
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                      // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM :u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if ((Tlc.get(step) >= (uint16_t)target) && state) break;        // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
	    }
      if (work) {
        if (TopSensor.Ranging(CM) <= data_Array[2] || BottomSensor.Ranging(CM) <= data_Array[3]) {		// если сработал любой из датчиков
          currentMotionTime = millis();																		// запоминаем текущее время 
          if (currentMotionTime - startMotionTime >= data_Array[6]) {										// если текущее время больше времени старта на установленное значение
            startMotionTime = currentMotionTime;																// сбросим стартовое время
            allStairWork();																						// вызываем ф-ю включения всей лестницы
            return;
          }   
        }
      
      if (step == data_Array[16] - 1) delay(data_Array[11] * 10);		// если достигли ступени-платформы разворота, задержка умноженная на 10
      else delay(data_Array[11]);											// для других ступеней обычная задержка
      }
   
    }
    outData(4, state ? "D" : "d", state);                             // ответ пользователю, что команда выполнена 
}
//==========================================================================================================================================

//------------ Включение/выключение всех ступеней разом ------------------------------------------------------------------------------------
void all (int bright, bool state) {                       // параметры (яркость, состояние 0-выключить, 1-включить)
  outData(3, state ? "A" : "a", state);                             // ответ пользователю, что команда выполняется
  DataSerialAvailable();                                            // проверяем, есть ли данные на входе
  if (stop) {                                                       // если флаг СТОП
    actionSTOP();                                                   	// вызываем функцию СТОП
    return;                                                           	// выходим из цикла
  }
  for (int step = 0; step < data_Array[8]; step ++) {   	          // увеличение ступеней от нижней до верхней с шагом "1"
    Tlc.set(step, bright);                         	                  // всем ступеням назначаем указанную яркость
  }
  Tlc.update();                                                     // применяем изменения
  outData(4, state ? "A" : "a", state);                             // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней от середины к краям ---------------------------------------------------------------------------
void different (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  int up, down;
  outData(3, state ? "F" : "f", state);                            // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                      // вычисляем среднюю ступень

    for (up = center, center % 2 == 0 ? down = center - 1: down = center; up < data_Array[8]; up ++, down --) {   // отсчет ведем в зависимости от четности ступеней 
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                       // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
        if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
        if ((Tlc.get(up) == (uint16_t)target || Tlc.get(down) == (uint16_t)target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей вверх
          Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей вниз
          Tlc.update();                                                  // применяем изменения
          delay(data_Array[15]);                                         // применяем установленную задержку
      } 
    } 
    outData(4, state ? "F" : "f", state);                                   // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение/выключение ступеней от краев навстречу друг другу ----------------------------------------------------------------- 
void towards (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  outData(3, state ? "T" : "t", state);                            // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                      // вычисляем среднюю ступень
    for (int up = 0, down = data_Array[8] - 1; center % 2 == 0 ? up < center: up <= center; up ++, down --) {   // в зависимости от четности ступеней устанавливаем среднюю ступень
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                       // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
        if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
        if ((Tlc.get(up) == (uint16_t)target || Tlc.get(down) == (uint16_t)target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей сверху
          Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей снизу
          Tlc.update();                                                  // применяем изменения
          delay(data_Array[15]);                                         // применяем установленную задержку
      }
    }
    outData(4, state ? "T" : "t", state);                                  // ответ пользователю, что команда выполняется 
}
//==========================================================================================================================================

//------------ Включение режима SOS --------------------------------------------------------------------------------------------------------
void sos (int bright, bool state) {                                  // параметры (яркость, состояние 1-включить)
  outData(3, "S", state);                                              // ответ пользователю, что команда выполняется

  byte cycle = 0;                                                       // 
  byte on = 0;
  int pause = 200;                                                      // задаем значение паузы
        Tlc.setAll(0);                                                  // выключаем все ступени
        Tlc.update();
  delay (1000);                                                         // пауза перед включением

  while (cycle < 3) {                                                   // если прошло менее трех циклов, то
    if (cycle == 2) {                                                     // если уже третий цикл
      delay (pause);                                                        // применяем паузу
      pause = 200;                                                          // меняем значение паузы
    }
    do {                                                                  // выполняем код ниже до условия
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
      delay (pause);                                                        // пауза
        Tlc.setAll(bright);                                                 // устанавливаем всем ступеням указанную яркость
        Tlc.update();                                                       // применяем изменения
      delay (pause);                                                        // пауза
        Tlc.setAll(0);                                                      // тушим все ступени
        Tlc.update();                                                       // применяем изменения
       on ++;                                                               // увеличиваем счетчик
    } while (on < 3);                                                     // условие - пока счетчик менее трех
    on = 0;                                                               // сбрасываем счетчик
    pause = 500;                                                          // меняем значение паузы
    cycle ++;                                                             // увеличиваем общий счетчик циклов
  }
  outData(4, "S", state);                                              // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Включение ступеней имитируя люминесцентную лампу ----------------------------------------------------------------------------
void luminescent (int bright) {                                      // параметры (яркость)

  byte f = 0;
  int pause = 1000;
  outData(3, "L", 1);                                              // ответ пользователю, что команда выполняется

  Tlc.setAll(0);
  Tlc.update();
  for (int first = 0, last = data_Array[8] - 1, b = 0; b <= bright ; b ++) {
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
    Tlc.set(first, b);
    Tlc.set(last, b);
    Tlc.update();
    delayMicroseconds(500);
  } 

  Tlc.setAll(bright);
  Tlc.update();
  delay(700);
  
  do {
      DataSerialAvailable();                                            // проверяем, есть ли данные на входе
      if (stop) {                                                       // если флаг СТОП
        actionSTOP();                                                         // вызываем функцию СТОП
        break;                                                          // выходим из цикла
      }      
    Tlc.setAll(bright/8);
    Tlc.update();

      delay(pause/2);

    for (int b = bright/8; b < bright; b ++) {
      Tlc.setAll(b);
      Tlc.update();
    }

    pause /= 4;
    f ++;
    delay(pause);
  } while (f < 5);

  outData(4, "L", 1);                                              // ответ пользователю, что команда выполнена
}
//==========================================================================================================================================

//------------ Проверка сенсоров -----------------------------------------------------------------------------------------------------------
int sensorsCheck (Ultrasonic sensor, int operateNumber) {
  byte tempNumber = operateNumber;
  int dist_3[3] = {0, 0, 0};                        // массив для хранения трёх последних измерений
  int dist = 0;                                         // переменная для текущей дистанции
  int result = 0;

  do {												// выполняем
    for (int i = 0; i < 3; i++) {                    	// счётчик от 0 до 2
      dist_3[i] = sensor.Ranging(CM);                  		// пишем дистанцию с датчика (в см.) в текущую ячейку массива
      delay(data_Array[5]);                            		// небольшая задержка необходима, чтобы эхо предыдущего сигнала не искажало текущий
    }
      dist = middle(dist_3[0], dist_3[1], dist_3[2]);   	// фильтровать медианным фильтром из 3-х последних измерений
      result += dist;										// сохраняем полученное значение
      tempNumber --;										// уменьшаем счетчик срабатываний
  } while (tempNumber > 0);							//пока счетчик больше ноля
  
    result = result / operateNumber;   				// делим полный результат на количество циклов измерений
    return result;                                  // вернем в функцию отфильтрованное значение дистанции
}
//==========================================================================================================================================

//------------ медианный фильтр из 3ёх значений --------------------------------------------------------------------------------------------
int middle(int a, int b, int c) {
  int middle;
  if ((a <= b) && (a <= c)) {                 // если a <= b и a <= c
    middle = (b <= c) ? b : c;                  // среднее равно b, если b <= c или c, если c < b
  }
  else if ((b <= a) && (b <= c)) {            // если b <= a и b <= c
      middle = (a <= c) ? a : c;                // среднее равно a, если a <= c или c, если c < a
    }
    else {                                    // если c <= a и c <= b
      middle = (a <= b) ? a : b;                // среднее равно a, если a <= b или b, если b < a
    }
  return middle;                              // вернем в функцию среднее значение
}
//==========================================================================================================================================

//------------ Проверка Темно или Светло ---------------------------------------------------------------------------------------------------
boolean DarkOrLight() {  // создаем булеву функцию проверки показаний фоторезистора (день или ночь)

    int FotoElem = 0;                       // переменная для снятия показаний фоторезистора;
    int a = 0, b = 0;                                // переменные для гистерезиса (а-включение-ночь, b-выключение-день)

    for(int i = 0; i < 1000; i++) {                  // запускаем счетчик от "0" до "1000"
        FotoElem = analogRead(FOTO);                     // пишем в переменную текущеее значение с фоторезистора
        if (FotoElem > data_Array[0]) {                  // если значение фоторезистора больше (темнее) референсного значения;
            a++;                                            // увеличиваем a
            b = 0;                                          // обнуляем b
          } else if (FotoElem < (data_Array[0] - data_Array[1])) {       // иначе, если значение меньше (светлее), чем референсное значение минус допуск на гистерезис;
            b++;                                            // увеличиваем b
            a = 0;                                          // обнуляем a
          }
      }
    if (!dark && (a > 999)) {                        // если светло и a больше 999
         dark = true;                                   // устанавливаем - темно!
      } else if (dark && (b > 999)) {                // иначе, если темно и b больше 999
         dark = false;                                  // устанавливаем - светло!
      } else {                                       // в остальных случаях
        a = 0;                                          // обнуляем a, b
        b = 0;
      }
    return dark;                                      // возвращаем в функцию значение темно или светло!
 }
//==========================================================================================================================================

//------------ Проверка День или Ночь ------------------------------------------------------------------------------------------------------
boolean DayOrNight() {  // создаем булеву функцию проверки показаний фоторезистора (день или ночь)
  
  currentTime = millis();                       // сохраняем в переменную текущее время в мс.

  if (currentTime - startTime >= 1000UL) {          // если разница между временем старта и текущим временем более или равна 1 сек.
    startTime = currentTime;                        	// стартовое время скинем до текущего

    switch (DarkOrLight()) {                           	// запускаем проверку светло/темно 
      case true:                  							// если темно
        if (Flags_Array[2]){                 					// и если ночь (флаг night)
          Flags_Array[2] = true;               						// подтверждаем ночь
          darkness = 0;               								// обнуляем счетчик темноты
        } else darkness --;         							//если день, уменьшаем счетчик темноты
        break;
      case false:                 							// если светло
        if (!Flags_Array[2]){               					// и если день
          Flags_Array[2] = false;              						// подтверждаем день
          darkness = 0;              								// обнуляем счетчик темноты
        } else darkness ++;;       								// иначе, если ночь,  увеличиваем счетчик темноты
        break;
    }
              // дополнительный фильтр день/ночь на случая кратковременных изменений (облака, тени и т.д.)
      if (darkness == -5) {       						// если счетчик темноты достиг -5
        darkness = 0;               						// обнуляем счетчик темноты
        Flags_Array[2] = true;               				// устанавливаем ночь
      }
      if (darkness == 5) {        						// если счетчик темноты достиг 5
        darkness = 0;               						// обнуляем счетчик темноты
        Flags_Array[2] = false;              				// устанавливаем день
      } 
  }
  return Flags_Array[2];
 }
//==========================================================================================================================================

//------------ Дежурное освещение ----------------------------------------------------------------------------------------------------------
void emergencyLighting(boolean val) { 			// включаем первую и последнюю ступеньки на дежурную яркость

  if(val) {											// если 1
    Tlc.set(0, data_Array[9]);							// первой ступени задаем значение дежурного освещения
    Tlc.set(data_Array[8] - 1, data_Array[9]);			// последней ступени задаем значение дежурного освещения
  } else {											// если 0
    Tlc.set(0, 0);										// выключаем первую ступень
    Tlc.set(data_Array[8] - 1, 0);						// выключаем последнюю ступень
  }
  Tlc.update();
}
//==========================================================================================================================================

//------------ Ответ на запрос состояния ---------------------------------------------------------------------------------------------------
void statusMode() {         // считаем, что при получении запроса состояния нужно переходить в режим StandBy
  standByTime = millis();   						// записываем время активации флага StandBy
  Flags_Array[0] = true;    						// поднимаем флаг StandBy
  btSerial.println("OK");   						// шлем ответ на запрос состояния
}
//==========================================================================================================================================

//------------ СТОП всех выполняемых команд ------------------------------------------------------------------------------------------------
void actionSTOP() {
  
  Tlc.setAll(0);                                    // всем ступеням назначаем указанную яркость
  Tlc.update();                                     // применяем изменения
  outData(4, "$",  0);                         		// ответ - команда выполнена
}
//==========================================================================================================================================

//------------ Включение всех ступеней с контролем датчиков --------------------------------------------------------------------------------
void allStairWork() {
    outData(3, "A", 1);                                   	// ответ пользователю, что команда выполняется
    allStair = true;
    for (int step = 0; step < data_Array[8]; step ++) {   	// увеличение ступеней от нижней до верхней с шагом "1"
      Tlc.set(step, data_Array[10]);                         	// включаем каждую ступень на максимальную яркость
    }
    Tlc.update();                                       	// применяем изменения
    outData(4, "A", 1);                                   	// ответ пользователю, что команда выполнена

     delay(data_Array[13]);                                 // задержка свечения всех ступеней
     outData(3, "d", 1);                             		// ответ пользователю, что команда выполняется
	 
     for (int pwm = data_Array[10]; pwm >= 0; pwm -= data_Array[14]) {  	// уменьшение яркости от максимума до "0" 
          if (pwm - data_Array[14] < data_Array[9] ) {                      // если остаточное значение ШИМ меньше, чем дежурное освещение, то
              Tlc.set(data_Array[8] - 1, data_Array[9]);           				// выключаем последнюю ступень до дежурной величины 
              Tlc.update();                               						// применяем изменения
              delay(data_Array[15]);                         					// задержка перед следующим шагом уменьшения яркости
            }
        }
        
     for (int step = data_Array[8] - 2; step >= 1; step --) {      // увеличение ступенек от предпоследней до второй с шагом "1"
          for (int pwm = data_Array[10]; pwm >= 0; pwm -= data_Array[14]) { // уменьшение яркости от максимума до "0" 
               if (pwm < data_Array[14]) pwm=0;                        	// проверка, если остаточное значение ШИМ меньше, чем шаг, то приравняем к "0"
               Tlc.set(step, pwm);                            			// выключаем каждую ступень поочередно с плавным уменьшением яркости
               Tlc.update();                                  			// применяем изменения
               delay(data_Array[15]);                            		// задержка перед следующим шагом уменьшения яркости
            }
          if(TopSensor.Ranging(CM) < data_Array[2] || BottomSensor.Ranging(CM) < data_Array[3]) {  // проверяем, если сработал верхний или нижний датчик,
               currentMotionTime = millis();                     		// пишем текущее время 
               if(currentMotionTime - startMotionTime > data_Array[6]) {  // если разность текущего времени и времени срабатывания больше заданного интервала
                   startMotionTime = currentMotionTime;           			// сбрасываем текущее время 
                   allStairWork();                             				// включаем все ступени на полную яркость
                   return;                                   				// покидаем функцию
                }
            }
          delay(data_Array[11]);                            			// задержка перед выключением следующей ступени
      }

     for (int pwm = data_Array[10]; pwm >= 0; pwm -= data_Array[14]) {      // уменьшение яркости от максимума до "0" 
              if (pwm - data_Array[14] < data_Array[9]) {                       // если остаточное значение ШИМ меньше, чем дежурное освещение, то
                  Tlc.set(0, data_Array[9]);                        				// выключаем первую ступень до дежурной величины
                  Tlc.update();                               						// применяем изменения
                  delay(data_Array[15]);                         					// задержка перед следующим шагом уменьшения яркости
                }
            }
    outData(4, "d", 1);                             					// ответ пользователю, что команда выполнена 
}
//==========================================================================================================================================
