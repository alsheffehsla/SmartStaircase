#include "Tlc5940.h"                  // подключаем библиотеку драйвера
#include "Ultrasonic.h"               // подключаем библиотеку ультразвуковых датчиков
#include <EEPROM.h>
#include <SoftwareSerial.h>

#define T1 6                          // устанавливаем контакты для верхнего датчика
#define E1 5                          // устанавливаем контакты для верхнего датчика
#define T2 7                          // устанавливаем контакты для нижнего датчика
#define E2 8                          // устанавливаем контакты для нижнего датчика
#define FOTO A1                       // устанавливаем контакт для фоторезистора
Ultrasonic TopSensor(T1, E1);        // определяем нижний датчик
Ultrasonic BottomSensor(T2, E2);         // определяем верхний датчик

boolean night = 0;                    // переключатель, если 0 - то день, 1 - ночь

String dataIn = "";
boolean data_flag, parse_flag, cycle_flag = false;
SoftwareSerial btSerial(2, 4); // RX, TX

int interceptBright = 0;
int interceptorArray [16][1] {};
// int temp_Array[17];
int data_Array[17];     // рабочий массив с настройками
int default_Array[17] = {980,10,80,90,7,50,2000,1,16,200,1900,50,3000,10000,50,10,9};   // дефолтные настройки
// int user_Array[17] лежит в EEPROM по адресу 0.
//int command;
// Изменяемые настройки:
//======================================================================================================================
// настройки фоторезистора
//unsigned int night = 980;             //[0] референсное значение фоторезистора, выше которого считается ночь;
//int hysteresis = 10;                  //[1] задержка переключения ночь-день
//настройки ультразвуковых датчиков
//int distanceTopOperate = 80;          //[2] расстояние, при котором сработает верхний датчик, (см)
//int distanceBottomOperate = 90;       //[3] расстояние, при котором сработает нижний датчик, (см)
//int distanceSwitch = 7;               //[4] расстояние, меньше которого сработает выключатель (включение/выключение всей лестницы), (см)
//int ZadergkaSensora = 50;             //[5] задержка между выстрелами сенсоров, (миллисекунды)
//int sensorPollingDelay = 2000;        //[6] интервал задержки срабатывания датчиков, чтобы одно пересечение не считалось за несколько, (миллисекунды)
//byte operateNumber = 1;               //[7] количество срабатываний датчика для запуска функций (защита от случайных срабатываний и эл.магн. помех)
// настройки свечения ступеней
//byte numberOfSteps = 16;              //[8] количество ступеней лестницы, (шт.)
//int emergencyLighting = 200;          //[9] яркость первой и последней ступенек в ночном режиме, (дежурное освещение)
//int maxBrightness = 1900;             //[10] максимальная яркость свечения, (min 0 - 4095 max)
//int delaySwitchingNextStep = 50;      //[11] задержка перед включением/выключением следующей ступени, (миллисекунды)
//int timeGlowStep = 3000; 			        //[12] задержка свечения каждой ступени перед выключением, (миллисекунды)
//int timeAllSteps = 10000;             //[13] задержка свечения всей лестницы, (миллисекунды)
//int stepPWM = 50;                     //[14] шаг увеличения яркости ШИМ, (min 0 - 4095 max)
//int delayPWM = 10;                    //[15] задержка между шагами ШИМ (плавное включение), (миллисекунды) нельзя устанавливать 0
//byte landing = 9;                     //[16] площадка разворота лестницы, (№ ступени)

int top = 0;
int bottom = 0;

//======================================================================================================================
// --------- Инициализация ---------------------------------------------------------------------------------------------
void setup() {
  if (EEPROM.read(1000) != 123){                    // если по адресу 1000 нет ключа со значением 123 (первый запуск) // (при запросе учитывать, что ячейки  двухбайтовые - адрес 500)
    EEPROM.write(1000, 123);                        // запишем ключ
    EEPROM.put(0,default_Array);                    // запишем в память массив с дефолтными настройками, начиная с адреса 0
  }

  Tlc.init(0);                                      // гасим все ступени
  btSerial.begin(57600);                            // открываем последовательный порт на скорости 57600
  Serial.begin(9600);         // раскоментировать для отладки
  EEPROM.get(0,data_Array);                      // загружаем из памяти в рабочий массив настройки пользователя
  //int interceptorArray [data_Array[8]][1] {};
}
//----------------------------------------------------------------------------------------------------------------------

void loop() {
/*
  DayOrNight();
  if (night) {
//    top = sensorsCheck(TopSensor, data_Array[7]);
//    bottom = sensorsCheck(BottomSensor, data_Array[7]);
    top = sensorsCheck(TopSensor, 3);
    bottom = sensorsCheck(BottomSensor, 3);
    if (bottom > 10 && bottom <= 100) {
      up(0, data_Array[10], data_Array[14], 1);
    } else if (top > 10 && top <= 100) {
      down(0, data_Array[10], data_Array[14], 1);
    } else all(0, 0);
  }  else sos(4095, 0);


//    top = sensorsCheck(TopSensor, 3);
 //   Serial.print("top :");
 //   Serial.println(top);
    bottom = sensorsCheck(BottomSensor, 3);
    Serial.print("bottom :");
    Serial.println(bottom);
*/

  //--------- Проверка наличия входных данных -------------------------------------------------------------
  while (btSerial.available()>0){                // если данные поступили
      dataIn += (char)btSerial.read();                // набиваем переменную данными
      data_flag = true;                                  // устанавливаем флаг, что данные получены
      delay(2);                                     // маленькая задержка (без нее коряво работает)
  }
  //-------------------------------------------------------------------------------------------------------
  //--------- Блок разбора полученных данных --------------------------------------------------------------
  if (data_flag) {                                       // проверяем, если флаг установлен
    data_flag = false;                                   // сбрасываем флаг
    String command = dataIn.substring(1);           // переносим данные в новую переменную без первого символа 
    
    switch ((uint8_t)dataIn[0]){                             // ищем совпадение по первому символу данных (в полной строке)
    //------- ???????? ------------------------------------------------------------------------------------
      case 0x24:                                     // если $
        btSerial.println(command);                  //

        break;
    //-----------------------------------------------------------------------------------------------------
    //------- Блок разбора и сохранения настроек ----------------------------------------------------------    
      case 0x23:                                     // если #
        if (command.endsWith("#")) {                              // если строка заканчивается #
          command = command.substring(0, command.length() - 1);       // обрезаем последний символ строки
          //    Serial.println("command: " + command);            
          getSettings(command);                                       // парсим строку
        } else {
          outData(2, command, 0);               // иначе - сообщение пользователю "Неверные данные"
        }
        break;
    //-----------------------------------------------------------------------------------------------------

    //------- Временный блок вывода значения из EEPROM по запросу -----------------------------------------
      case 0x21:                                     // если !
        // Serial.println(command);            
        qwerty(command);                                // 
        break;
    //-----------------------------------------------------------------------------------------------------

    //------- Временный блок для отладки (выводит все данные из рабочего массива и из EEPROM) -------------  
      case 0x3F:                                     // если ?
            for (int i=0; i < (int)(sizeof(data_Array)/sizeof(int)); i++){
              btSerial.print(data_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
/*        EEPROM.get(0,temp_Array);
            for (int i=0; i < (int)(sizeof(data_Array)/sizeof(int)); i++){
              btSerial.print(temp_Array[i]);
              btSerial.print(":");
            }
            btSerial.println();
*/        break;
    //-----------------------------------------------------------------------------------------------------

    //------- Временный блок для отладки (обнуление ключа EEPROM) ------//
      case 0x2A:                                       // если *
        EEPROM.put(1000,255);
        break;
    //------------------------------------------------------------------//
      
      case 0x40:                                   // если @
        parser (command);                           // парсим строку принятых данных
        break;
    //-----------------------------------------------------------------//  

    //------ Блок ошибки (если команда не распознана)  
      default:                                    // если совпадений нет
        outData(1, dataIn.substring(0, 1), 0);                 // сообщение пользователю "Неверная команда"
        break;
    }
    dataIn = "";                                  // обнуляем входные данные
    command = "";
    
  }
}

//------------ Временный блок для отладки (удалить) -------------------------------------
void qwerty (String qwerty){            // принимаем значение
          int t;
          int ini = qwerty.toInt();           // преобразовываем его в адрес
          EEPROM.get(ini*2, t);                 // вытаскиваем данные из EEPROM по данному адресу из массива
          btSerial.println(t);                  // печатаем значение
}
//---------------------------------------------------------------------------------------

//------------ Блок парсера пользовательских настроек с записью в память и рабочий массив ---------------------------------------------------
void getSettings (String data) {                      // получаем блок данных (строка с данными и разделителями)
  String temp;
  int addr, val;
  do {                                                        // выполнить
    if (data.indexOf(";", 0) != -1) {                             // если блок содержит хоть один разделитель ';' 
      temp = data.substring(0, data.indexOf(";", 0));                 // во временную переменную пишем подстроку до ближайшего разделителя ';'
      data.remove(0, data.indexOf(";", 0)+1);                         // обрезаем блок от начала вместе с разделителем ';'      
      if (temp[1] == ':' || temp[2] == ':') {                         // если 2-й или 3-й символ это разделитель ':'
        addr = temp.substring(0,temp.indexOf(":", 0)).toInt();          // записываем в переменную адрес (значение до разделителя ':')
        val = temp.substring(temp.indexOf(":", 0)+1).toInt();           // записываем в переменную само значение (после разделителя ':')
        data_Array[addr] = val;                                         // пишем значение по указанному адресу в рабочий массив
      //  EEPROM.put((addr)*2,val);             временно отключен - переписать запись по требованию приложения     // пишем значение по указанному адресу в EEPROM
        onlineBright(val);                                              // вызов функции немедленного изменения яркости
      }
    } else {                                                      
      outData(2, data, 0);                                      // иначе - сообщение пользователю "Неверные данные"
      break;
    }
  } while (data != "");                                       // повторяем цикл, пока не закончится блок с данными
  temp = "";                                                  // обнуляем переменные
  val = 0; 
  addr = 0;
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//------------ Блок вывода сообщений пользователю -------------------------------------------------------------------------------------------
void outData (int value, String dataOut, byte additional){              // принимаем блок данных (вид сообщения, данные, дополнительные данные)
  switch (value) {                                        // ищем совпадения по значению
    case 1:                                                   // если 1, то 
      btSerial.print(100);              // вывод сообщения "Неверная команда" со значением команды
      break;
    case 2:                                                   // если 2, то 
      btSerial.print(200);              // вывод сообщения "Неверные данные" со значением
      break;
    case 3:                                                   // если 3, то 
      btSerial.print(300);              // вывод сообщения "Команда принята" со значением      
      break;
    case 4:                                                   // если 4, то
      btSerial.print(400);                // вывод сообщения "Команда выполнена" со значением
      break;
    default:
      btSerial.print(500);                // внутренняя ошибка  ?????
  }
  btSerial.print(",");
  btSerial.println(dataOut);
/*  if (additional == 0 || additional == 1) {
    btSerial.print(",");
    btSerial.println(additional, HEX);
  }
*/
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//------------ Блок парсера сценариев -------------------------------------------------------------------------------------------------------
void parser (String data){                                     // получаем данные
  String tempdata;
  String cycledata = data;                                     // сохраняем набор команд на случай зацикливания
  do {
    tempdata = data.substring(0, 1);
    data.remove(0,1);
    switch (tempdata.charAt(0)) {                              // ищем совпадение по символу
      case 0x4F:                                                    // включение контроллера лестницы

        break;
      case 0x6F:                                                    // выключение контроллера лестницы

        break;
      case 0x50:                                                    // команда СТОП

        break;
      case 0x58:                                                    // запрос состояния контроллера лестницы

        break;
      case 0x55:
        up(0, data_Array[10], data_Array[14], 1);                   // включаем ступени последовательно вверх
        break;
      case 0x75:
        up(data_Array[10], 0, data_Array[14], 0);                   // выключаем ступени последовательно вверх
        break;
      case 0x44:
        down(0, data_Array[10], data_Array[14], 1);                 // включаем ступени последовательно вниз
        break;
      case 0x64:
        down(data_Array[10], 0, data_Array[14], 0);                 // выключаем ступени последовательно вниз
        break;
      case 0x41:
        all(data_Array[10], 1);                                     // включаем все ступени разом
        break;
      case 0x61:
        all(0, 0);                                                  // выключаем все ступени разом
        break;
      case 0x46:
        different(0, data_Array[10], data_Array[14], 1);            // включаем ступени от середины в разные стороны
        break;
      case 0x66:
        different(data_Array[10], 0, data_Array[14], 0);            // выключаем ступени от середины в разные стороны
        break;
      case 0x54:
        towards(0, data_Array[10], data_Array[14], 1);              // включаем ступени навстречу с разных сторон
        break;
      case 0x74:
        towards(data_Array[10], 0, data_Array[14], 0);              // выключаем ступени навстречу с разных сторон
        break;
      case 0x53:
        sos(4095, 0);                                               // режим SOS, (максимальная яркость, зациклить -1 или один раз -0)
        break;
      case 0x4C:
        luminescent(data_Array[10]);                                // включаем все ступени с эффектом люминесцентной лампы
        break;
      case 0x43:                                                    // зациклить сценарии
        cycle_flag = true;
        break;
      case 0x63:                                                    // отмена зацикливания сценариев
        cycle_flag = false;
        break;
      default:                                                      // если совпадений нет
        outData (2, tempdata, 0);                         // сообщение оператору "Неверные данные"
        break;
      }
  } while (data != "");                                   // пока не кончатся команды
  if (cycle_flag) {
    data = cycledata;
  }
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//-------------Изменение яркости "на лету"---------------------------------------------------------------------------------------------------
void onlineBright (int val) {
    for (int i = 0; i <= data_Array[8]; i++) {
      Tlc.set(i, val);
  }
  Tlc.update();
}
//-------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней снизу вверх ------------------------------------------------------------------------------------
void up (int initVal, int target, int stepPWM, bool state) {          // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
    outData(3, state ? "U" : "u", state);                             // ответ пользователю, что команда выполняется
    for (int step = 0; step < data_Array[8]; step ++) {                 // начиная с 0 увеличиваем ступень на 1
/*      if (btSerial.available()>0) {                                       // проверяем, если есть новые данные на входе, то
          Tlc.clear();                                                      // тушим все ступени
          Tlc.update();                                                     // применяем изменения
          break;                                                            // покидаем блок
        }
*/      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if (Tlc.get(step) == target && state) break;                    // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
	      }
   }
   outData(4, state ? "U" : "u", state);                             // ответ пользователю, что команда выполнена
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней сверху вниз -----------------------------------------------------------------------------------
void down (int initVal, int target, int stepPWM, bool state) {        // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
    outData(3, state ? "D" : "d", state);                             // ответ пользователю, что команда выполняется
    for (int step = data_Array[8]; step >= 0; step --) {                // начиная с последней уменьшаем ступень на 1
/*      if (btSerial.available()>0) {                                        // проверяем, если есть новые данные на входе, то
          Tlc.clear();                                                        // тушим все ступени
          Tlc.update();                                                       // применяем изменения
          break;                                                              // покидаем блок
        }
*/      for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM :u -= stepPWM){   // устанавливаем новое значение яркости в зависимости от состояния
        if (!Tlc.get(step) && !state) break;                            // если в процессе тушения ступень уже была выключена, то покидаем блок
        if (Tlc.get(step) == target && state) break;                    // если в процессе включения ступень уже была включена, то покидаем блок
          Tlc.set(step, u);                                               // устанавливаем значение яркости текущей ступени
          Tlc.update();                                                   // применяем изменения
          delay(data_Array[15]);                                          // применяем установленную задержку
	      }
    }
    outData(4, state ? "D" : "d", state);                             // ответ пользователю, что команда выполнена 
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение всех ступеней разом ------------------------------------------------------------------------------------
void all (int bright, bool state) {                                     // параметры (яркость, состояние 0-выключить, 1-включить)
  outData(3, state ? "A" : "a", state);                                   // ответ пользователю, что команда выполняется
  Tlc.setAll(bright);                                                       // всем ступеням назначаем указанную яркость
  for (int i = 0; i <= data_Array[8]; i++) {
    interceptorArray[i][1] = bright;
  }
  Tlc.update();                                                             // применяем изменения
  outData(4, state ? "A" : "a", state);                                   // ответ пользователю, что команда выполнена
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней от середины к краям ---------------------------------------------------------------------------
void different (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  int up, down;
  outData(3, state ? "F" : "f", state);                                   // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                            // вычисляем среднюю ступень

    for (up = center, center % 2 == 0 ? down = center - 1: down = center; up < data_Array[8]; up ++, down --) {   // отсчет ведем в зависимости от четности ступеней 
/*      if (btSerial.available()>0) {                                         // проверяем, если есть новые данные на входе, то
          all(0, 0);                                                        // тушим все ступени
          break;                                                            // покидаем блок
        }
*/        for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
          if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
          if ((Tlc.get(up) == target || Tlc.get(down) == target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
            Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей вверх
            Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей вниз
            Tlc.update();                                                  // применяем изменения
            delay(data_Array[15]);                                         // применяем установленную задержку
        } 
    } 
    outData(4, state ? "F" : "f", state);                                   // ответ пользователю, что команда выполнена
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение/выключение ступеней от краев навстречу друг другу ----------------------------------------------------------------- 
void towards (int initVal, int target, int stepPWM, bool state) {    // параметры (нач.значение, целевое значение, шаг, состояние 0-выключить 1-включить)
  outData(3, state ? "T" : "t", state);                                  // ответ пользователю, что команда выполняется
  byte center = data_Array[8]/2;                                           // вычисляем среднюю ступень

    for (int up = 0, down = data_Array[8] - 1; center % 2 == 0 ? up < center: up <= center; up ++, down --) {   // в зависимости от четности ступеней устанавливаем среднюю ступень
/*      if (btSerial.available()>0) {                                        // проверяем, если есть новые данные на входе, то
          all(0, 0);                                                       // тушим все ступени
          break;                                                           // покидаем блок
        }
*/        for (int u = initVal; state ? u < target : u >= target; state ? u += stepPWM : u -= stepPWM) {    // устанавливаем новое значение яркости в зависимости от состояния
          if ((!Tlc.get(up) || !Tlc.get(down)) && !state) break;                      // если в процессе тушения ступень уже была выключена, то покидаем блок
          if ((Tlc.get(up) == target || Tlc.get(down) == target) && state) break;     // если в процессе включения ступень уже была включена, то покидаем блок
            Tlc.set(up, u);                                                // устанавливаем значение яркости ступени идущей сверху
            Tlc.set(down, u);                                              // устанавливаем значение яркости ступени идущей снизу
            Tlc.update();                                                  // применяем изменения
            delay(data_Array[15]);                                         // применяем установленную задержку
        }
    }
    outData(4, state ? "T" : "t", state);                                  // ответ пользователю, что команда выполняется 
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение режима SOS --------------------------------------------------------------------------------------------------------
void sos (int bright, bool state) {                                  // параметры (яркость, состояние 1-включить)
  outData(3, "S", state);                                              // ответ пользователю, что команда выполняется

  byte cycle = 0;                                                       // 
  byte on = 0;
  int pause = 200;                                                      // задаем значение паузы
        Tlc.setAll(0);                                                  // выключаем все ступени
        Tlc.update();
  delay (1000);                                                         // пауза перед включением

  while (cycle < 3) {                                                   // если прошло менее трех циклов, то
/*    if (btSerial.available()>0) {                                         // проверяем, если есть новые данные на входе, то
          all(0, 0);                                                      // тушим все ступени
          break;                                                          // покидаем блок
        }
*/    if (cycle == 2) {                                                     // если уже третий цикл
      delay (pause);                                                        // применяем паузу
      pause = 200;                                                          // меняем значение паузы
    }
    do {                                                                  // выполняем код ниже до условия
      delay (pause);                                                        // пауза
        Tlc.setAll(bright);                                                 // устанавливаем всем ступеням указанную яркость
        Tlc.update();                                                       // применяем изменения
      delay (pause);                                                        // пауза
        Tlc.setAll(0);                                                      // тушим все ступени
        Tlc.update();                                                       // применяем изменения
       on ++;                                                               // увеличиваем счетчик
    } while (on < 3);                                                     // условие - пока счетчик менее трех
    on = 0;                                                               // сбрасываем счетчик
    pause = 500;                                                          // меняем значение паузы
    cycle ++;                                                             // увеличиваем общий счетчик циклов
  }
  outData(4, "S", state);                                              // ответ пользователю, что команда выполнена
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Включение ступеней имитируя люминесцентную лампу ----------------------------------------------------------------------------
void luminescent (int bright) {                                      // параметры (яркость)

  byte f = 0;
  int pause = 1000;
  outData(3, "L", 1);                                              // ответ пользователю, что команда выполняется

  Tlc.setAll(0);
  Tlc.update();
  for (int first = 0, last = data_Array[8] - 1, b = 0; b <= bright ; b ++) {
/*    if (btSerial.available()>0) {
          all(0, 0);
          break;
        }
*/    Tlc.set(first, b);
    Tlc.set(last, b);
    Tlc.update();
    delayMicroseconds(500);
  } 

  Tlc.setAll(bright);
  Tlc.update();
  delay(700);
  
  do {
/*    if (btSerial.available()>0) {
          all(0, 0);
          break;
        }
*/    Tlc.setAll(bright/8);
    Tlc.update();

      delay(pause/2);

    for (int b = bright/8; b < bright; b ++) {
      Tlc.setAll(b);
      Tlc.update();
    }

    pause /= 4;
    f ++;
    delay(pause);
    Serial.println(pause);
  } while (f < 5);

  outData(4, "L", 1);                                              // ответ пользователю, что команда выполнена
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Проверка сенсоров -----------------------------------------------------------------------------------------------------------
long sensorsCheck (Ultrasonic sensor, byte operateNumber) {
  int temp = 0;
  temp = sensor.Ranging(CM);
  Serial.print("sensor 1");
  Serial.print(" :");
  Serial.println(temp);
  temp = 0;
  for (int i=0; i < operateNumber; i++) {
    temp += sensor.Ranging(CM);
    Serial.println(temp);
    delay(50);
  }
  temp = temp / operateNumber;
  Serial.print("sensor 2");
  Serial.print(" :");
  Serial.println(temp);
  delay(5000);
  return temp;
}
//------------------------------------------------------------------------------------------------------------------------------------------

//------------ Проверка День или Ночь ------------------------------------------------------------------------------------------------------
boolean DayOrNight() {  // создаем булеву функцию проверки показаний фоторезистора (день или ночь)

    unsigned int FotoElem = 0;                            // переменная для снятия показаний фоторезистора;
    int i;                                                    // Счетчик для зажигания и тушения диодов, определения день/ночь;
    int a = 0, b = 0;                                // переменные для гистерезиса (а-включение-ночь, b-выключение-день)

    for(i = 0; i < 10000; i++) {                                  // увеличение счетчика от "0" до "49"
        FotoElem = analogRead(FOTO);                     // пишем в переменную текущеее значение с фоторезистора
        if (FotoElem > data_Array[0]) {                      // если значение фоторезистора больше (темнее) референсного значения;
            a++; 
            b = 0;
          } else if (FotoElem < (data_Array[0] - data_Array[1])) {       // если меньше (светлее), чем референсное значение минус допуск на гистерезис;
            b++; 
            a = 0;
          }
      }
    if (!night && (a > 9999)) { 
         night = true;
      } else if (night && (b > 9999)) { 
         night = false;
      } else {
        a = 0;
        b = 0;
      }
 }